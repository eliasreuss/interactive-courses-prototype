<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FlowScript Course Creator</title>
    <style>
        :root {
            --primary-blue: #007bff; --light-gray: #f8f9fa; --medium-gray: #dee2e6; --dark-gray: #343a40;
            --red: #dc3545; --green: #28a745; --yellow: #ffc107; --cyan: #17a2b8;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: var(--light-gray); color: var(--dark-gray); margin: 0; padding: 20px; }
        .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        h1, h2, h3, h4 { color: #212529; }
        h2 { border-bottom: 2px solid #e9ecef; padding-bottom: 10px; }
        .node-card { border: 1px solid var(--medium-gray); border-radius: 6px; padding: 20px; margin-bottom: 20px; background-color: #fff; }
        input[type="text"], input[type="number"], textarea, select { width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; margin-bottom: 10px; font-size: 1rem; }
        textarea { min-height: 120px; resize: vertical; }
        label { font-weight: 600; display: block; margin-bottom: 5px; }
        .label-with-button { display: flex; justify-content: space-between; align-items: center; }
        button { background-color: var(--primary-blue); color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 0.9rem; margin-right: 5px; transition: background-color 0.2s; }
        button:hover { background-color: #0056b3; }
        .btn-add { background-color: var(--green); }
        .btn-add:hover { background-color: #218838; }
        .btn-remove { background-color: var(--red); }
        .btn-remove:hover { background-color: #c82333; }
        .btn-generate { background-color: var(--yellow); color: #212529; font-weight: bold; width: 100%; padding: 15px; font-size: 1.2rem; margin-top: 20px; }
        .btn-generate:hover { background-color: #e0a800; }
        .connection-row, .sidequest-row { display: flex; gap: 15px; align-items: flex-start; margin-bottom: 15px; border-left: 3px solid var(--medium-gray); padding: 15px; border-radius: 4px;}
        .sidequest-row { border-left-color: var(--cyan); }
        .connection-inputs { flex: 2; }
        .sidequest-content-area { flex: 1.5; }
        .output-area { margin-top: 20px; }
        #outputText { width: 100%; min-height: 400px; background-color: #e9ecef; color: #495057; font-family: monospace; font-size: 0.9rem; border-radius: 4px; }
        #upload-btn { background-color: #6c757d; }
        #upload-btn:hover { background-color: #5a6268; }
        .top-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    </style>
</head>
<body>

<div class="container">
    <div class="top-controls">
        <h1>FlowScript Course Creator</h1>
        <label for="file-input" id="upload-btn" class="button" style="display:inline-block; padding: 10px 15px; cursor:pointer;">
            ðŸ“¤ Upload & Edit .txt File
        </label>
        <input type="file" id="file-input" accept=".txt" style="display: none;">
    </div>
    <p>Create a new course from scratch, or upload an existing <code>.txt</code> file to continue editing it.</p>
    <div id="nodes-container"></div>
    <button id="add-node-btn" class="btn-add">âž• Add Main Path Node</button>
    <div class="output-area">
        <h2>Output</h2>
        <button id="generate-btn" class="btn-generate">1. Generate & Preview Course Text</button>
        <textarea id="outputText" readonly placeholder="Your generated course.txt content will appear here..."></textarea>
        <button id="download-btn" style="margin-top: 10px; display: none;">2. Download .txt File</button>
    </div>
</div>

<!-- TEMPLATES (hidden) -->
<template id="node-template">
    <div class="node-card">
        <button class="btn-remove" style="float: right;">Remove Node</button>
        <h3>Node Details</h3>
        <label>Node ID:</label><input type="number" class="node-id" required>
        <label>Node Title:</label><input type="text" class="node-title">
        <label>Node Type:</label>
        <select class="node-type">
            <option value="main" selected>Standard Content</option>
            <option value="flip-cards">Flip Cards</option>
        </select>
        <div class="node-content-area">
            <!-- Standard content editor -->
            <div class="standard-content-editor">
                <div class="label-with-button">
                    <label>Node Content:</label>
                    <div>
                        <button type="button" class="add-list-btn" style="margin-bottom: 5px;">Add Bullet List</button>
                        <button type="button" class="add-image-btn" style="margin-bottom: 5px;">Add Image</button>
                    </div>
                </div>
                <textarea class="node-content" placeholder="Use **text** for bold. For lists, use '* ' or '- '. For images, use the button or type ![alt text|size:medium](image.png)." required></textarea>
            </div>
            <!-- Flip cards editor -->
            <div class="flip-cards-editor" style="display: none;">
                <div class="flip-cards-container"></div>
                <button type="button" class="add-flip-card-btn">Add Flip Card</button>
            </div>
        </div>
        <h4>Connections</h4>
        <div class="connections-container"></div>
        <button class="add-connection-btn">Add Main Path Link</button>
        <button class="add-sidequest-btn">Add Side Quest</button>
        <button class="add-link-btn">Add Link Button</button>
    </div>
</template>

<template id="connection-template">
    <div class="connection-row">
        <div class="connection-inputs" style="display: flex; align-items: center; gap: 10px; width: 100%;">
            <input type="text" class="conn-text" placeholder="Button Text" required style="flex: 1;">
            <span>âž”</span>
            <input type="number" class="conn-target" placeholder="Target ID" required style="flex: 0.5;">
        </div>
        <button class="btn-remove">âœ–</button>
    </div>
</template>

<template id="sidequest-template">
    <div class="sidequest-row">
        <div class="connection-inputs">
            <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 10px;">
                <input type="text" class="sq-btn-text" placeholder="Button Text" required>
                <span>âž” [</span>
                <select class="sq-type">
                    <option value="video">video</option><option value="now">now</option><option value="case">case</option>
                </select>
                <span>:</span>
                <input type="text" class="sq-title" placeholder="Side Quest Title" required>
                <span>]</span>
            </div>
        </div>
        <div class="sidequest-content-area">
            <div class="label-with-button">
                <label>Side Quest Content:</label>
                <div>
                    <button type="button" class="add-list-btn" style="margin-bottom: 5px;">Add Bullet List</button>
                    <button type="button" class="add-image-btn" style="margin-bottom: 5px;">Add Image</button>
                </div>
            </div>
            <textarea class="sq-content" placeholder="Paste a YouTube URL here to embed a video, or any other URL for a link. You can also use lists, bold text, and sized images." required></textarea>
        </div>
        <button class="btn-remove">âœ–</button>
    </div>
</template>
<template id="flip-card-template">
    <div class="flip-card-row" style="border-left: 3px solid var(--cyan); padding: 15px; margin-bottom: 15px; border-radius: 4px;">
        <button class="btn-remove" style="float: right;">âœ–</button>
        <label>Card Front Content:</label>
        <textarea class="flip-card-front" placeholder="Content for the front of the card..." rows="3"></textarea>
        <label>Card Back Content:</label>
        <textarea class="flip-card-back" placeholder="Content for the back of the card..." rows="3"></textarea>
    </div>
</template>

<template id="link-template">
    <div class="link-row" style="border-left: 3px solid var(--green); padding: 15px; margin-bottom: 15px; border-radius: 4px;">
        <button class="btn-remove" style="float: right;">âœ–</button>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
            <input type="text" class="link-btn-text" placeholder="Button Text (e.g., 'Open Documentation')" required style="flex: 1;">
            <span>âž”</span>
            <input type="url" class="link-url" placeholder="URL (e.g., https://example.com)" required style="flex: 2;">
        </div>
    </div>
</template>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // All existing variables are the same
    const nodesContainer = document.getElementById('nodes-container');
    const addNodeBtn = document.getElementById('add-node-btn');
    const generateBtn = document.getElementById('generate-btn');
    const downloadBtn = document.getElementById('download-btn');
    const fileInput = document.getElementById('file-input');
    const nodeTemplate = document.getElementById('node-template');
    const connectionTemplate = document.getElementById('connection-template');
    const sidequestTemplate = document.getElementById('sidequest-template');
    const flipCardTemplate = document.getElementById('flip-card-template');
    const linkTemplate = document.getElementById('link-template');
    const outputText = document.getElementById('outputText');
    let nodeIdCounter = 1;

    // The functions for adding nodes, connections, parsing, etc., are all the same.
    // ... (All previous JS functions from last correct answer go here) ...
    function addNewNode(id = null, title = '', content = '') {
        const nodeCard = nodeTemplate.content.cloneNode(true).querySelector('.node-card');
        nodeCard.querySelector('.node-id').value = id !== null ? id : nodeIdCounter++;
        nodeCard.querySelector('.node-title').value = title;
        nodeCard.querySelector('.node-content').value = content;
        nodesContainer.appendChild(nodeCard);
        return nodeCard;
    }
    function addConnectionToNode(nodeCard, text = '', target = '') {
        const container = nodeCard.querySelector('.connections-container');
        const newConn = connectionTemplate.content.cloneNode(true);
        newConn.querySelector('.conn-text').value = text;
        newConn.querySelector('.conn-target').value = target;
        container.appendChild(newConn);
    }
    function addSideQuestToNode(nodeCard, btnText = '', type = 'video', title = '', content = '') {
        const container = nodeCard.querySelector('.connections-container');
        const newSQ = sidequestTemplate.content.cloneNode(true);
        newSQ.querySelector('.sq-btn-text').value = btnText;
        newSQ.querySelector('.sq-type').value = type;
        newSQ.querySelector('.sq-title').value = title;
        newSQ.querySelector('.sq-content').value = content;
        container.appendChild(newSQ);
    }
    
    function addLinkToNode(nodeCard, btnText = '', url = '') {
        const container = nodeCard.querySelector('.connections-container');
        const newLink = linkTemplate.content.cloneNode(true);
        newLink.querySelector('.link-btn-text').value = btnText;
        newLink.querySelector('.link-url').value = url;
        container.appendChild(newLink);
    }

    nodesContainer.addEventListener('change', e => {
        if (e.target.classList.contains('node-type')) {
            const card = e.target.closest('.node-card');
            const type = e.target.value;
            const standardEditor = card.querySelector('.standard-content-editor');
            const flipEditor = card.querySelector('.flip-cards-editor');

            if (type === 'flip-cards') {
                standardEditor.style.display = 'none';
                flipEditor.style.display = 'block';
            } else {
                standardEditor.style.display = 'block';
                flipEditor.style.display = 'none';
            }
        }
    });

    // --- START: NEW, ROBUST PARSER (from index.html) ---
    function parseFlowScript(text) {
        const sideQuestContentMap = new Map();
        const mainNodes = [];
        let currentBlock = null;

        const sqRegex = /\[side-quest-content:([^\]]+)\]\s*\n---\n([\s\S]*?)\n---/g;
        let remainingText = text.replace(sqRegex, (match, fullType, content) => {
            // Handle both old format (type only) and new format (type:title)
            const parts = fullType.trim().split(':');
            const type = parts[0];
            const title = parts[1] || '';
            
            if (title) {
                // New format: type:title
                sideQuestContentMap.set(`${type}:${title}`, content.trim());
            } else {
                // Old format: type only (for backward compatibility)
                sideQuestContentMap.set(type, content.trim());
            }
            return '';
        });

        const lines = remainingText.split('\n');
        let isContent = false;
        
        for (const line of lines) {
            if (line.trim().startsWith('id:')) {
                if (currentBlock) mainNodes.push(currentBlock);
                currentBlock = { connections: {}, sideQuests: [], content: '' };
                isContent = false;
            }

            if (!currentBlock) continue;

            if (line.trim() === '---') {
                isContent = !isContent;
                continue;
            }

            if (isContent) {
                currentBlock.content = (currentBlock.content || '') + line + '\n';
            } else {
                if (line.startsWith('>')) {
                    const mainMatch = line.match(/>\s*(.+?)\s*->\s*(\d+)/);
                    const sqMatch = line.match(/>\s*(.+?)\s*->\s*\[(video|now|case):(.+?)\]/);
                    const linkMatch = line.match(/>\s*(.+?)\s*->\s*\[link:(.+)\]/);
                    if (mainMatch) {
                        currentBlock.connections[mainMatch[1].trim()] = parseInt(mainMatch[2]);
                    } else if (sqMatch) {
                        const [, buttonText, type, title] = sqMatch;
                        // Try multiple matching strategies for content lookup
                        let content = sideQuestContentMap.get(`${type}:${title}`);
                        
                        if (!content) {
                            // Try to find content by partial title match (for legacy compatibility)
                            for (const [key, value] of sideQuestContentMap.entries()) {
                                if (key.startsWith(`${type}:`)) {
                                    const keyTitle = key.split(':', 2)[1];
                                    // Check if either title contains the other (partial match)
                                    if (title.includes(keyTitle) || keyTitle.includes(title)) {
                                        content = value;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (!content) {
                            // Final fallback to type-only match
                            content = sideQuestContentMap.get(type) || '';
                        }
                        
                        currentBlock.sideQuests.push({ type, title, buttonText, content });
                    } else if (linkMatch) {
                        const [, buttonText, url] = linkMatch;
                        if (!currentBlock.links) currentBlock.links = [];
                        currentBlock.links.push({ buttonText: buttonText.trim(), url: url.trim().replace(/\]$/, '') });
                    }
                } else {
                    const [key, ...valueParts] = line.split(':');
                    if (valueParts.length > 0) {
                        const value = valueParts.join(':').trim();
                        currentBlock[key.trim()] = key.trim() === 'id' ? parseInt(value) : value;
                    }
                }
            }
        }
        if (currentBlock) mainNodes.push(currentBlock);

        mainNodes.forEach(node => {
            if (node.content) node.content = node.content.trim();
        });
        
        return mainNodes;
    }

    function parseAndRender(text) {
        nodesContainer.innerHTML = '';
        let maxId = 0;
        const courseData = parseFlowScript(text);

        courseData.forEach(nodeData => {
            if (!nodeData || !nodeData.id) return;
            
            // Determine node type and handle content accordingly
            let nodeType = 'main';
            let content = nodeData.content || '';
            
            if (nodeData.type === 'flip-cards') {
                nodeType = 'flip-cards';
            }
            
            const nodeCard = addNewNode(nodeData.id, nodeData.title, content);
            
            // Set the node type and handle flip card content
            const typeSelect = nodeCard.querySelector('.node-type');
            typeSelect.value = nodeType;
            
            if (nodeType === 'flip-cards') {
                // Parse flip card content and populate the flip card editor
                const flipCards = parseFlipCardContent(content);
                const flipEditor = nodeCard.querySelector('.flip-cards-editor');
                const flipCardsContainer = flipEditor.querySelector('.flip-cards-container');
                
                // Clear existing flip cards
                flipCardsContainer.innerHTML = '';
                
                // Add each flip card
                flipCards.forEach(card => {
                    const cardTemplate = document.getElementById('flip-card-template');
                    const newCard = cardTemplate.content.cloneNode(true);
                    newCard.querySelector('.flip-card-front').value = card.front;
                    newCard.querySelector('.flip-card-back').value = card.back;
                    flipCardsContainer.appendChild(newCard);
                });
                
                // Show flip card editor, hide standard editor
                nodeCard.querySelector('.standard-content-editor').style.display = 'none';
                flipEditor.style.display = 'block';
            }

            for (const [text, target] of Object.entries(nodeData.connections)) {
                addConnectionToNode(nodeCard, text, target);
            }

            nodeData.sideQuests.forEach(sq => {
                addSideQuestToNode(nodeCard, sq.buttonText, sq.type, sq.title, sq.content);
            });

            if (nodeData.links) {
                nodeData.links.forEach(link => {
                    addLinkToNode(nodeCard, link.buttonText, link.url);
                });
            }

            if (nodeData.id > maxId) maxId = nodeData.id;
        });

        nodeIdCounter = courseData.length > 0 ? maxId + 1 : 1;
    }
    
    function parseFlipCardContent(content) {
        const cards = [];
        const cardBlocks = content.split('[card-separator]');
        
        cardBlocks.forEach(block => {
            const trimmedBlock = block.trim();
            if (!trimmedBlock.startsWith('[card]')) return;
            
            let front = 'Click to reveal';
            let back = '';
            
            const lines = trimmedBlock.split('\n').slice(1); // Skip the [card] line
            let currentKey = '';
            let contentBuffer = '';
            
            lines.forEach(line => {
                const frontMatch = line.match(/^front:\s*(.*)/);
                const backMatch = line.match(/^back:\s*(.*)/);
                
                if (frontMatch) {
                    if (currentKey === 'back') { // Finished back content
                        back = contentBuffer.trim();
                        contentBuffer = '';
                    }
                    currentKey = 'front';
                    contentBuffer = frontMatch[1];
                } else if (backMatch) {
                    if (currentKey === 'front') { // Finished front content
                        front = contentBuffer.trim();
                        contentBuffer = '';
                    }
                    currentKey = 'back';
                    contentBuffer = backMatch[1];
                } else if (currentKey) {
                    contentBuffer += '\n' + line;
                }
            });
            
            // Set final content
            if (currentKey === 'front') {
                front = contentBuffer.trim();
            } else if (currentKey === 'back') {
                back = contentBuffer.trim();
            }
            
            if (front || back) {
                cards.push({ front, back });
            }
        });
        
        return cards;
    }
    // --- END: NEW, ROBUST PARSER ---
    
    // --- Event listener for "Add Image" and "Add List" buttons ---
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('add-image-btn')) {
            const imageFile = prompt("Enter the image filename (e.g., my-image.png):");
            if (!imageFile) return;

            const altText = prompt("Enter a short description (alt text):", "image");
            
            const size = prompt("Enter image size (e.g., x-small, small, medium, large, or a custom height like '150px'):", "large");
            if (!size) return;
            
            const align = prompt("Enter image alignment (left, center, right, or stack-right):", "center");
            if (!align) return;

            let attributes = [];
            if (size) attributes.push(`size:${size.trim()}`);
            if (align && ['left', 'center', 'right', 'stack-right'].includes(align.trim())) {
                attributes.push(`align:${align.trim()}`);
            }
            
            const markdown = `![${altText}/${attributes.join('/')}](${imageFile})`;
            insertTextAtCursor(e.target, markdown);
        }
        
        if (e.target.classList.contains('add-list-btn')) {
            const listMarkdown = "\n* List item 1\n* List item 2\n";
            insertTextAtCursor(e.target, listMarkdown);
        }

        if (e.target.classList.contains('add-flip-card-btn')) {
            const container = e.target.previousElementSibling;
            const cardTemplate = document.getElementById('flip-card-template');
            container.appendChild(cardTemplate.content.cloneNode(true));
        }
    });

    function insertTextAtCursor(buttonElement, textToInsert) {
        const parent = buttonElement.closest('.label-with-button, .sidequest-content-area');
        const textarea = parent.nextElementSibling.tagName === 'TEXTAREA' ? parent.nextElementSibling : parent.querySelector('textarea');
        
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const text = textarea.value;
        textarea.value = text.substring(0, start) + textToInsert + text.substring(end);
        textarea.focus();
        textarea.selectionStart = textarea.selectionEnd = start + textToInsert.length;
    }

    if (nodesContainer.children.length === 0) addNewNode();
    addNodeBtn.addEventListener('click', () => addNewNode());
    nodesContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('btn-remove')) e.target.closest('.node-card, .connection-row, .sidequest-row, .flip-card-row, .link-row').remove();
        else if (e.target.classList.contains('add-connection-btn')) addConnectionToNode(e.target.closest('.node-card'));
        else if (e.target.classList.contains('add-sidequest-btn')) addSideQuestToNode(e.target.closest('.node-card'));
        else if (e.target.classList.contains('add-link-btn')) addLinkToNode(e.target.closest('.node-card'));
    });
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            try { parseAndRender(event.target.result); alert('Course successfully loaded!'); }
            catch (error) { console.error("Error parsing file:", error); alert("Could not parse file."); }
        };
        reader.readAsText(file); e.target.value = '';
    });
    generateBtn.addEventListener('click', () => {
        let finalOutput = '# Auto-generated by FlowScript Course Creator\n\n'; const sideQuestContentMap = new Map();
        document.querySelectorAll('.node-card').forEach(card => {
            const id = card.querySelector('.node-id').value;
            const title = card.querySelector('.node-title').value;
            const type = card.querySelector('.node-type').value;
            
            if (!id) return;
            
            let content = '';
            if (type === 'flip-cards') {
                const flipCards = [];
                card.querySelectorAll('.flip-card-row').forEach(row => {
                    const front = row.querySelector('.flip-card-front').value;
                    const back = row.querySelector('.flip-card-back').value;
                    if (front || back) {
                       flipCards.push(`[card]\nfront: ${front}\nback: ${back}`);
                    }
                });
                content = flipCards.join('\n[card-separator]\n');
            } else {
                content = card.querySelector('.node-content').value;
            }

            finalOutput += `id: ${id}\ntitle: ${title}\ntype: ${type}\n---\n${content.trim()}\n---\n`;
            
            card.querySelectorAll('.connection-row').forEach(conn => { const text = conn.querySelector('.conn-text').value, target = conn.querySelector('.conn-target').value; if(text && target) finalOutput += `> ${text} -> ${target}\n`; });
            card.querySelectorAll('.sidequest-row').forEach(sq => {
                const btnText = sq.querySelector('.sq-btn-text').value, type = sq.querySelector('.sq-type').value, sqTitle = sq.querySelector('.sq-title').value, sqContent = sq.querySelector('.sq-content').value;
                if (btnText && type && sqTitle) { 
                    finalOutput += `> ${btnText} -> [${type}:${sqTitle}]\n`; 
                    if (sqContent) {
                        // Use type:title as the unique key to handle multiple side quests of the same type
                        const uniqueKey = `${type}:${sqTitle}`;
                        sideQuestContentMap.set(uniqueKey, sqContent.trim()); 
                    }
                }
            });
            card.querySelectorAll('.link-row').forEach(link => {
                const btnText = link.querySelector('.link-btn-text').value;
                const url = link.querySelector('.link-url').value;
                if (btnText && url) {
                    finalOutput += `> ${btnText} -> [link:${url}]\n`;
                }
            });
            finalOutput += '\n';
        });
        sideQuestContentMap.forEach((content, uniqueKey) => { 
            const [type, title] = uniqueKey.split(':', 2);
            finalOutput += `[side-quest-content:${type}:${title}]\n---\n${content}\n---\n\n`; 
        });
        outputText.value = finalOutput.trim(); downloadBtn.style.display = 'inline-block'; alert('Course text generated!');
    });
    downloadBtn.addEventListener('click', () => {
        const textToSave = outputText.value; if (!textToSave) return alert("Generate text first!");
        const blob = new Blob([textToSave], { type: 'text/plain' }); const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'course-edited.txt';
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    });
});
</script>

</body>
</html>