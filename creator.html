<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FlowScript Course Creator</title>
    <style>
        :root {
            --primary-blue: #007bff; --light-gray: #f8f9fa; --medium-gray: #dee2e6; --dark-gray: #343a40;
            --red: #dc3545; --green: #28a745; --yellow: #ffc107; --cyan: #17a2b8;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; background-color: var(--light-gray); color: var(--dark-gray); margin: 0; padding: 20px; }
        .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        h1, h2, h3, h4 { color: #212529; }
        h2 { border-bottom: 2px solid #e9ecef; padding-bottom: 10px; }
        .node-card { border: 1px solid var(--medium-gray); border-radius: 6px; padding: 20px; margin-bottom: 20px; background-color: #fff; }
        input[type="text"], input[type="number"], textarea, select { width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 4px; box-sizing: border-box; margin-bottom: 10px; font-size: 1rem; }
        textarea.node-content, textarea.sq-content, textarea.flip-card-front, textarea.flip-card-back { min-height: 120px; resize: vertical; }
        label { font-weight: 600; display: block; margin-bottom: 5px; }
        .label-with-button { display: flex; justify-content: space-between; align-items: center; }
        button { background-color: var(--primary-blue); color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 0.9rem; margin-right: 5px; transition: background-color 0.2s; }
        button:hover { background-color: #0056b3; }
        .btn-add { background-color: var(--green); }
        .btn-add:hover { background-color: #218838; }
        .btn-remove { background-color: var(--red); }
        .btn-remove:hover { background-color: #c82333; }
        .btn-generate { background-color: var(--yellow); color: #212529; font-weight: bold; width: 100%; padding: 15px; font-size: 1.2rem; margin-top: 20px; }
        .btn-generate:hover { background-color: #e0a800; }
        .connection-row, .sidequest-row { display: flex; gap: 15px; align-items: flex-start; margin-bottom: 15px; border-left: 3px solid var(--medium-gray); padding: 15px; border-radius: 4px;}
        .sidequest-row { border-left-color: var(--cyan); }
        .connection-inputs { flex: 1; }
        .sidequest-content-area { flex: 3; }
        .output-area { margin-top: 20px; }
        #outputText { width: 100%; min-height: 400px; background-color: #e9ecef; color: #495057; font-family: monospace; font-size: 0.9rem; border-radius: 4px; }
        #upload-btn { background-color: #6c757d; }
        #upload-btn:hover { background-color: #5a6268; }
        .top-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    </style>
</head>
<body>

<div class="container">
    <div class="top-controls">
        <h1>FlowScript Course Creator</h1>
        <label for="file-input" id="upload-btn" class="button" style="display:inline-block; padding: 10px 15px; cursor:pointer;">
            ðŸ“¤ Upload & Edit .txt File
        </label>
        <input type="file" id="file-input" accept=".txt" style="display: none;">
    </div>
    <p>Create a new course from scratch, or upload an existing <code>.txt</code> file to continue editing it.</p>
    <div id="nodes-container"></div>
    <button id="add-node-btn" class="btn-add">âž• Add Main Path Node</button>
    <div class="output-area">
        <h2>Output</h2>
        <button id="generate-btn" class="btn-generate">1. Generate & Preview Course Text</button>
        <textarea id="outputText" readonly placeholder="Your generated course.txt content will appear here..."></textarea>
        <button id="download-btn" style="margin-top: 10px; display: none;">2. Download .txt File</button>
    </div>
</div>

<!-- TEMPLATES (hidden) -->
<template id="node-template">
    <div class="node-card">
        <button class="add-node-below-btn" style="float: right; margin-right: 8px;">Add Node Below</button>
        <button class="add-node-above-btn" style="float: right; margin-right: 8px;">Add Node Above</button>
        <button class="btn-remove" style="float: right;">Remove Node</button>
        <h3>Node Details</h3>
        <label>Node ID:</label><input type="number" class="node-id" required>
        <label>Node Title:</label><textarea class="node-title" rows="2" placeholder="Use **text** for bold."></textarea>
        <label>Title Alignment:</label>
        <select class="node-title-align">
            <option value="left" selected>Left</option>
            <option value="center">Center</option>
        </select>
        <label>Node Type:</label>
        <select class="node-type">
            <option value="main" selected>Standard Content</option>
            <option value="flip-cards">Flip Cards</option>
        </select>
        <div class="node-content-area">
            <!-- Standard content editor -->
            <div class="standard-content-editor">
                <div class="label-with-button">
                    <label>Node Content:</label>
                    <div>
                        <button type="button" class="add-list-btn" style="margin-bottom: 5px;">Add Bullet List</button>
                        <button type="button" class="add-image-btn" style="margin-bottom: 5px;">Add Image</button>
                        <button type="button" class="add-video-btn" style="margin-bottom: 5px;">Add Video</button>
                        <button type="button" class="add-image-row-btn" style="margin-bottom: 5px;">Add Image Row (3)</button>
                        <button type="button" class="add-quote-btn" style="margin-bottom: 5px;">Add Quote</button>
                    </div>
                </div>
                <textarea class="node-content" placeholder="Use **text** for bold. For lists, use '* ' or '- '. For images, use the button or type ![alt text|size:medium](image.png)." required></textarea>
            </div>
            <!-- Flip cards editor -->
            <div class="flip-cards-editor" style="display: none;">
                <label>Flip Cards Intro (optional):</label>
                <textarea class="flip-intro" placeholder="Intro/body text that appears above the flip cards..." rows="3"></textarea>
                <div class="flip-cards-container"></div>
                <button type="button" class="add-flip-card-btn">Add Flip Card</button>
            </div>
        </div>
        <h4>Connections</h4>
        <div class="connections-container"></div>
        <button class="add-connection-btn">Add Main Path Link</button>
        <button class="add-sidequest-btn">Add Side Quest</button>
        <button class="add-link-btn">Add Link Button</button>
    </div>
</template>

<template id="connection-template">
    <div class="connection-row">
        <div class="connection-inputs" style="display: flex; align-items: center; gap: 10px; width: 100%;">
            <input type="text" class="conn-text" placeholder="Button Text" required style="flex: 1;">
            <span>âž”</span>
            <input type="number" class="conn-target" placeholder="Target ID" required style="flex: 0.5;">
        </div>
        <button class="btn-remove">âœ–</button>
    </div>
</template>

<template id="sidequest-template">
    <div class="sidequest-row">
        <div class="connection-inputs">
            <div style="display: flex; gap: 5px; align-items: center; margin-bottom: 10px;">
                <input type="text" class="sq-btn-text" placeholder="Button Text" required>
                <span>âž” [</span>
                <select class="sq-type">
                    <option value="video">video</option><option value="now">now</option><option value="case">case</option>
                </select>
                <span>:</span>
                <input type="text" class="sq-title" placeholder="Side Quest Title" required>
                <span>]</span>
            </div>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                <input type="text" class="sq-next-label" placeholder="Next button text (default: Next)">
                <input type="text" class="sq-back-label" placeholder="Back button text (default: Return to main path)">
            </div>
        </div>
        <div class="sidequest-content-area">
            <div class="label-with-button">
                <label>Side Quest Content:</label>
                <div>
                    <button type="button" class="add-list-btn" style="margin-bottom: 5px;">Add Bullet List</button>
                    <button type="button" class="add-image-btn" style="margin-bottom: 5px;">Add Image</button>
                    <button type="button" class="add-video-btn" style="margin-bottom: 5px;">Add Video</button>
                    <button type="button" class="add-image-row-btn" style="margin-bottom: 5px;">Add Image Row (3)</button>
                    <button type="button" class="add-quote-btn" style="margin-bottom: 5px;">Add Quote</button>
                    <button type="button" class="add-inline-button" style="margin-bottom: 5px;">Add Link Button</button>
                    <button type="button" class="add-sq-card-btn" style="margin-bottom: 5px;">Add Side Quest Card</button>
                </div>
            </div>
            <div class="sq-card-wrap" style="margin-bottom: 10px;">
                <div style="display:flex; gap:10px; margin: 5px 0;">
                    <input type="text" class="sq-card-title" placeholder="Card title (optional)" style="flex:1;">
                </div>
                <div style="display:flex; gap:10px; margin: 5px 0;">
                    <input type="text" class="sq-card-next-label" placeholder="Next label (optional)" style="flex:1;">
                    <input type="text" class="sq-card-prev-label" placeholder="Previous label (optional)" style="flex:1;">
                </div>
                <textarea class="sq-content" placeholder="Card content. You can paste URLs, add lists, images, etc." required></textarea>
            </div>
        </div>
        <button class="btn-remove">âœ–</button>
    </div>
</template>
<template id="flip-card-template">
    <div class="flip-card-row" style="border-left: 3px solid var(--cyan); padding: 15px; margin-bottom: 15px; border-radius: 4px;">
        <button class="btn-remove" style="float: right;">âœ–</button>
        <label>Card Front Content:</label>
        <textarea class="flip-card-front" placeholder="Content for the front of the card..." rows="3"></textarea>
        <label>Card Back Content:</label>
        <textarea class="flip-card-back" placeholder="Content for the back of the card..." rows="3"></textarea>
    </div>
</template>

<template id="link-template">
    <div class="link-row" style="border-left: 3px solid var(--green); padding: 15px; margin-bottom: 15px; border-radius: 4px;">
        <button class="btn-remove" style="float: right;">âœ–</button>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
            <input type="text" class="link-btn-text" placeholder="Button Text (e.g., 'Open Documentation')" required style="flex: 1;">
            <span>âž”</span>
            <input type="url" class="link-url" placeholder="URL (e.g., https://example.com)" required style="flex: 2;">
            <label style="display:flex; gap:6px; align-items:center; white-space:nowrap;">
                <input type="checkbox" class="link-target-newtab" checked>
                Open in new tab
            </label>
        </div>
    </div>
</template>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // All existing variables are the same
    const nodesContainer = document.getElementById('nodes-container');
    const addNodeBtn = document.getElementById('add-node-btn');
    const generateBtn = document.getElementById('generate-btn');
    const downloadBtn = document.getElementById('download-btn');
    const fileInput = document.getElementById('file-input');
    const nodeTemplate = document.getElementById('node-template');
    const connectionTemplate = document.getElementById('connection-template');
    const sidequestTemplate = document.getElementById('sidequest-template');
    const flipCardTemplate = document.getElementById('flip-card-template');
    const linkTemplate = document.getElementById('link-template');
    const outputText = document.getElementById('outputText');
    let nodeIdCounter = 1;

    // The functions for adding nodes, connections, parsing, etc., are all the same.
    // ... (All previous JS functions from last correct answer go here) ...
    function addNewNode(id = null, title = '', content = '', titleAlign = 'left', insertBeforeElement = null) {
        const nodeCard = nodeTemplate.content.cloneNode(true).querySelector('.node-card');
        nodeCard.querySelector('.node-id').value = id !== null ? id : nodeIdCounter++;
        nodeCard.querySelector('.node-title').value = title;
        const alignSel = nodeCard.querySelector('.node-title-align');
        if (alignSel) alignSel.value = (titleAlign === 'center') ? 'center' : 'left';
        const contentArea = nodeCard.querySelector('.node-content');
        if (contentArea) contentArea.value = content;
        if (insertBeforeElement && insertBeforeElement.parentElement === nodesContainer) {
            nodesContainer.insertBefore(nodeCard, insertBeforeElement);
        } else {
            nodesContainer.appendChild(nodeCard);
        }
        return nodeCard;
    }
    function addConnectionToNode(nodeCard, text = '', target = '') {
        const container = nodeCard.querySelector('.connections-container');
        const newConn = connectionTemplate.content.cloneNode(true);
        newConn.querySelector('.conn-text').value = text;
        newConn.querySelector('.conn-target').value = target;
        container.appendChild(newConn);
    }
    function addSideQuestToNode(nodeCard, btnText = '', type = 'video', title = '', contentOrCards = '', nextLabel = '', backLabel = '') {
        const container = nodeCard.querySelector('.connections-container');
        const newSQ = sidequestTemplate.content.cloneNode(true);
        newSQ.querySelector('.sq-btn-text').value = btnText;
        newSQ.querySelector('.sq-type').value = type;
        newSQ.querySelector('.sq-title').value = title;
        if (nextLabel) newSQ.querySelector('.sq-next-label').value = nextLabel;
        if (backLabel) newSQ.querySelector('.sq-back-label').value = backLabel;
        const area = newSQ.querySelector('.sidequest-content-area');
        const firstWrap = area.querySelector('.sq-card-wrap');
        const cards = Array.isArray(contentOrCards) ? contentOrCards : (contentOrCards ? [contentOrCards] : ['']);
        if (cards.length > 0) {
            const c0 = cards[0];
            if (typeof c0 === 'object') {
                firstWrap.querySelector('.sq-card-title').value = c0.title || '';
                firstWrap.querySelector('.sq-card-next-label').value = c0.nextLabel || '';
                firstWrap.querySelector('.sq-card-prev-label').value = c0.prevLabel || '';
                firstWrap.querySelector('.sq-content').value = c0.content || '';
            } else {
                firstWrap.querySelector('.sq-content').value = c0;
            }
            for (let i = 1; i < cards.length; i++) {
                const wrap = document.createElement('div');
                wrap.className = 'sq-card-wrap';
                wrap.style.marginBottom = '10px';
                wrap.innerHTML = `<div style="display:flex; gap:10px; margin: 5px 0;"><input type="text" class="sq-card-title" placeholder="Card title (optional)" style="flex:1;"></div><div style="display:flex; gap:10px; margin: 5px 0;"><input type="text" class="sq-card-next-label" placeholder="Next label (optional)" style="flex:1;"><input type="text" class="sq-card-prev-label" placeholder="Previous label (optional)" style="flex:1;"></div><textarea class="sq-content" placeholder="Card content. You can paste URLs, add lists, images, etc." required></textarea>`;
                const ci = cards[i];
                if (typeof ci === 'object') {
                    wrap.querySelector('.sq-card-title').value = ci.title || '';
                    wrap.querySelector('.sq-card-next-label').value = ci.nextLabel || '';
                    wrap.querySelector('.sq-card-prev-label').value = ci.prevLabel || '';
                    wrap.querySelector('.sq-content').value = ci.content || '';
                } else {
                    wrap.querySelector('.sq-content').value = ci;
                }
                area.appendChild(wrap);
            }
        }
        container.appendChild(newSQ);
    }
    
    function addLinkToNode(nodeCard, btnText = '', url = '') {
        const container = nodeCard.querySelector('.connections-container');
        const newLink = linkTemplate.content.cloneNode(true);
        newLink.querySelector('.link-btn-text').value = btnText;
        newLink.querySelector('.link-url').value = url;
        container.appendChild(newLink);
    }

    nodesContainer.addEventListener('change', e => {
        if (e.target.classList.contains('node-type')) {
            const card = e.target.closest('.node-card');
            const type = e.target.value;
            const standardEditor = card.querySelector('.standard-content-editor');
            const flipEditor = card.querySelector('.flip-cards-editor');

            if (type === 'flip-cards') {
                standardEditor.style.display = 'none';
                flipEditor.style.display = 'block';
            } else {
                standardEditor.style.display = 'block';
                flipEditor.style.display = 'none';
            }
        }
    });

    // --- START: NEW, ROBUST PARSER (from index.html) ---
    function parseFlowScript(text) {
        const sideQuestContentMap = new Map();
        const mainNodes = [];
        let currentBlock = null;

        const sqRegex = /\[side-quest-content:([^\]]+)\]\s*\n---\n([\s\S]*?)\n---/g;
        let remainingText = text.replace(sqRegex, (match, fullType, content) => {
            // fullType can be like "type:title|next=...|back=..."
            const firstColon = fullType.indexOf(':');
            const type = firstColon >= 0 ? fullType.slice(0, firstColon).trim() : fullType.trim();
            const rest = firstColon >= 0 ? fullType.slice(firstColon + 1) : '';
            const barIdx = rest.indexOf('|');
            const title = (barIdx >= 0 ? rest.slice(0, barIdx) : rest).trim();
            const optsStr = barIdx >= 0 ? rest.slice(barIdx + 1) : '';
            const opts = {};
            optsStr.split('|').forEach(p => {
                const [k, ...vparts] = p.split('=');
                if (!k || vparts.length === 0) return;
                opts[k.trim()] = vparts.join('=').trim();
            });
            const raw = (content || '').trim();
            const parts = raw.length ? raw.split(/\n\[sq-card-separator\]\n/) : [''];
            const cardObjs = parts.map(p => {
                let t = p.trim();
                let nextLabel = '';
                let prevLabel = '';
                let title = '';
                const lines = t.split('\n');
                while (lines.length && /^\[(next|prev|title):/.test(lines[0].trim())) {
                    const m = lines.shift().trim().match(/^\[(next|prev|title):\s*(.+?)\]$/);
                    if (m) {
                        if (m[1] === 'next') nextLabel = m[2]; else if (m[1] === 'prev') prevLabel = m[2]; else title = m[2];
                    } else { break; }
                }
                return { content: lines.join('\n').trim(), nextLabel, prevLabel, title };
            });
            const key = title ? `${type}:${title}` : type;
            sideQuestContentMap.set(key, { cards: cardObjs, nextLabel: opts.next || '', backLabel: opts.back || '' });
            return '';
        });

        const lines = remainingText.split('\n');
        let isContent = false;
        
        for (const line of lines) {
            if (line.trim().startsWith('id:')) {
                if (currentBlock) mainNodes.push(currentBlock);
                currentBlock = { connections: {}, sideQuests: [], content: '' };
                isContent = false;
            }

            if (!currentBlock) continue;

            if (line.trim() === '---') {
                isContent = !isContent;
                continue;
            }

            if (isContent) {
                currentBlock.content = (currentBlock.content || '') + line + '\n';
            } else {
                if (line.startsWith('>')) {
                    const mainMatch = line.match(/>\s*(.+?)\s*->\s*(\d+)/);
                    const sqMatch = line.match(/>\s*(.+?)\s*->\s*\[(video|now|case):(.+?)\]/);
                    const linkMatch = line.match(/>\s*(.+?)\s*->\s*\[link:(.+)\]/);
                    if (mainMatch) {
                        currentBlock.connections[mainMatch[1].trim()] = parseInt(mainMatch[2]);
                    } else if (sqMatch) {
                        const [, buttonText, type, title] = sqMatch;
                        // Try multiple matching strategies for content lookup
                        let meta = sideQuestContentMap.get(`${type}:${title}`);
                        
                        if (!meta) {
                            // Try to find content by partial title match (for legacy compatibility)
                            for (const [key, value] of sideQuestContentMap.entries()) {
                                if (key.startsWith(`${type}:`)) {
                                    const keyTitle = key.split(':', 2)[1];
                                    // Check if either title contains the other (partial match)
                                    if (title.includes(keyTitle) || keyTitle.includes(title)) {
                                        meta = value;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (!meta) {
                            // Final fallback to type-only match
                            meta = sideQuestContentMap.get(type) || { cards: [''], nextLabel: '', backLabel: '' };
                        }
                        
                        const cards = Array.isArray(meta) ? meta : (meta.cards || ['']);
                        const nextLabel = meta.nextLabel || '';
                        const backLabel = meta.backLabel || '';
                        currentBlock.sideQuests.push({ type, title, buttonText, cards, nextLabel, backLabel });
                    } else if (linkMatch) {
                        const [, buttonText, url] = linkMatch;
                        if (!currentBlock.links) currentBlock.links = [];
                        currentBlock.links.push({ buttonText: buttonText.trim(), url: url.trim().replace(/\]$/, '') });
                    }
                } else {
                    const [key, ...valueParts] = line.split(':');
                    if (valueParts.length > 0) {
                        let value = valueParts.join(':').trim();
                        if (key.trim() === 'title') { value = value.replace(/<br>/g, '\n'); }
                        if (key.trim() === 'title-align') { currentBlock['title-align'] = value.toLowerCase(); continue; }
                        currentBlock[key.trim()] = key.trim() === 'id' ? parseInt(value) : value;
                    }
                }
            }
        }
        if (currentBlock) mainNodes.push(currentBlock);

        mainNodes.forEach(node => { if (node.content) node.content = node.content.trim(); });
        
        return mainNodes;
    }

    function parseAndRender(text) {
        nodesContainer.innerHTML = '';
        let maxId = 0;
        const courseData = parseFlowScript(text);

        courseData.forEach(nodeData => {
            if (!nodeData || !nodeData.id) return;
            
            // Determine node type and handle content accordingly
            let nodeType = 'main';
            let content = nodeData.content || '';
            
            if (nodeData.type === 'flip-cards') {
                nodeType = 'flip-cards';
            }
            
            const nodeCard = addNewNode(nodeData.id, nodeData.title, content, (nodeData['title-align'] || 'left'));
            
            // Set the node type and handle flip card content
            const typeSelect = nodeCard.querySelector('.node-type');
            typeSelect.value = nodeType;
            
            if (nodeType === 'flip-cards') {
                // Parse flip card content and populate the flip card editor
                const parsed = parseFlipCardContent(content);
                const flipEditor = nodeCard.querySelector('.flip-cards-editor');
                const flipCardsContainer = flipEditor.querySelector('.flip-cards-container');
                // Intro
                const introArea = flipEditor.querySelector('.flip-intro');
                introArea.value = parsed.intro || '';
                
                // Clear existing flip cards
                flipCardsContainer.innerHTML = '';
                
                // Add each flip card
                parsed.cards.forEach(card => {
                    const cardTemplate = document.getElementById('flip-card-template');
                    const newCard = cardTemplate.content.cloneNode(true);
                    newCard.querySelector('.flip-card-front').value = card.front;
                    newCard.querySelector('.flip-card-back').value = card.back;
                    flipCardsContainer.appendChild(newCard);
                });
                
                // Show flip card editor, hide standard editor
                nodeCard.querySelector('.standard-content-editor').style.display = 'none';
                flipEditor.style.display = 'block';
            }

            for (const [text, target] of Object.entries(nodeData.connections)) {
                addConnectionToNode(nodeCard, text, target);
            }

            nodeData.sideQuests.forEach(sq => {
                addSideQuestToNode(nodeCard, sq.buttonText, sq.type, sq.title, Array.isArray(sq.cards) ? sq.cards : (sq.content ? [sq.content] : ['']), sq.nextLabel || '', sq.backLabel || '');
            });

            if (nodeData.links) {
                nodeData.links.forEach(link => {
                    addLinkToNode(nodeCard, link.buttonText, link.url);
                });
            }

            if (nodeData.id > maxId) maxId = nodeData.id;
        });

        nodeIdCounter = courseData.length > 0 ? maxId + 1 : 1;
    }
    
    function parseFlipCardContent(content) {
        const result = { intro: '', cards: [] };
        if (!content) return result;
        let working = content;
        // Support explicit intro block
        const introMatch = working.match(/\[intro\]\n([\s\S]*?)\n\[\/intro\]\n?/);
        if (introMatch) {
            result.intro = introMatch[1].trim();
            working = working.replace(introMatch[0], '');
        } else {
            // Or treat any preface text before first [card] as intro
            const firstCardIdx = working.indexOf('[card]');
            if (firstCardIdx > 0) {
                result.intro = working.slice(0, firstCardIdx).trim();
                working = working.slice(firstCardIdx);
            }
        }
        const cards = [];
        const cardBlocks = working.split('[card-separator]');
        
        cardBlocks.forEach(block => {
            const trimmedBlock = block.trim();
            if (!trimmedBlock.startsWith('[card]')) return;
            
            let front = 'Click to reveal';
            let back = '';
            
            const lines = trimmedBlock.split('\n').slice(1); // Skip the [card] line
            let currentKey = '';
            let contentBuffer = '';
            
            lines.forEach(line => {
                const frontMatch = line.match(/^front:\s*(.*)/);
                const backMatch = line.match(/^back:\s*(.*)/);
                
                if (frontMatch) {
                    if (currentKey === 'back') { // Finished back content
                        back = contentBuffer.trim();
                        contentBuffer = '';
                    }
                    currentKey = 'front';
                    contentBuffer = frontMatch[1];
                } else if (backMatch) {
                    if (currentKey === 'front') { // Finished front content
                        front = contentBuffer.trim();
                        contentBuffer = '';
                    }
                    currentKey = 'back';
                    contentBuffer = backMatch[1];
                } else if (currentKey) {
                    contentBuffer += '\n' + line;
                }
            });
            
            // Set final content
            if (currentKey === 'front') {
                front = contentBuffer.trim();
            } else if (currentKey === 'back') {
                back = contentBuffer.trim();
            }
            
            if (front || back) {
                cards.push({ front, back });
            }
        });
        
        result.cards = cards;
        return result;
    }
    // --- END: NEW, ROBUST PARSER ---
    
    // --- Event listener for "Add Image" and "Add List" buttons ---
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('add-image-btn')) {
            const imageFile = prompt("Enter the image filename (e.g., my-image.png):");
            if (!imageFile) return;

            const altText = prompt("Enter a short description (alt text):", "image");
            
            const size = prompt("Enter image size (e.g., x-small, small, medium, large, third, or a custom height like '150px'):", "large");
            if (!size) return;
            
            const align = prompt("Enter image alignment (left, center, right, stack-right, or stack-right-top):", "center");
            if (!align) return;
            const border = prompt("Frame? Type 'none' for no border/shadow, or leave blank:", "");

            let attributes = [];
            if (size) attributes.push(`size:${size.trim()}`);
            if (align && ['left', 'center', 'right', 'stack-right', 'stack-right-top'].includes(align.trim())) {
                attributes.push(`align:${align.trim()}`);
            }
            if (border && border.trim().length) attributes.push(`frame:${border.trim()}`);
            
            const markdown = `![${altText}/${attributes.join('/')}](${imageFile})`;
            insertTextAtCursor(e.target, markdown);
        }

        if (e.target.classList.contains('add-video-btn')) {
            const videoFile = prompt("Enter the video filename (e.g., motion.mp4 or animation.json):");
            if (!videoFile) return;

            const altText = prompt("Enter a short description (alt text):", "motion graphic");
            
            const size = prompt("Enter video size (e.g., small, medium, large, third, or '300px'):", "medium");
            if (!size) return;
            
            const align = prompt("Enter video alignment (left, center, right, stack-right, or stack-right-top):", "stack-right");
            if (!align) return;
            const border = prompt("Frame? Type 'none' for no border/shadow, or leave blank:", "");

            let attributes = [];
            if (size) attributes.push(`size:${size.trim()}`);
            if (align && ['left', 'center', 'right', 'stack-right', 'stack-right-top'].includes(align.trim())) {
                attributes.push(`align:${align.trim()}`);
            }
            if (border && border.trim().length) attributes.push(`frame:${border.trim()}`);
            
            const isJson = /\.json(\?|$)/i.test(videoFile.trim());
            const mediaType = isJson ? 'lottie' : 'video';
            const markdown = `![${mediaType}:${altText}/${attributes.join('/')}](${videoFile})`;
            insertTextAtCursor(e.target, markdown);
        }
        
        if (e.target.classList.contains('add-image-row-btn')) {
            const countStr = prompt("How many images in the row? (2-4)", "3");
            if (!countStr) return; const count = Math.max(2, Math.min(4, parseInt(countStr, 10) || 3));
            const sizeDefault = count === 4 ? 'fourth' : (count === 3 ? 'third' : (count === 2 ? 'medium' : 'small'));
            const size = prompt("Enter image size for the row (e.g., fourth, third, small, medium, large or '200px'):", sizeDefault);
            if (!size) return;
            const align = prompt("Enter row alignment (left, center, right):", "center");
            if (!align) return;
            const border = prompt("Frame? Type 'none' for no border/shadow, or leave blank for default:", "none");
            const parts = [];
            for (let i = 1; i <= count; i++) {
                const file = prompt(`Image ${i} filename (e.g., img${i}.png):`);
                if (!file) return; // cancel if any missing
                const alt = prompt(`Image ${i} alt text:`, `image ${i}`) || `image ${i}`;
                const attrs = [`size:${size.trim()}`, `align:${align.trim()}`];
                if (border && border.trim().length) attrs.push(`frame:${border.trim()}`);
                parts.push(`![${alt}/${attrs.join('/')}](${file})`);
            }
            const row = parts.join(' ') + '\n';
            insertTextAtCursor(e.target, row);
        }

        if (e.target.classList.contains('add-quote-btn')) {
            const quote = prompt('Quote text:', 'We can now document exactly how we optimize the warehouse and show management exactly what is working and what is not');
            if (!quote) return;
            const author = prompt('Attribution (e.g., Name, Title or Company):', 'Purchasing manager at Aubo') || '';
            const block = `\n[quote]\ntext: ${quote}\nauthor: ${author}\n[/quote]\n`;
            insertTextAtCursor(e.target, block);
        }

        if (e.target.classList.contains('add-list-btn')) {
            const listMarkdown = "\n* List item 1\n* List item 2\n";
            insertTextAtCursor(e.target, listMarkdown);
        }

        if (e.target.classList.contains('add-inline-button')) {
            const label = prompt('Button label', 'Open Resource');
            const url = prompt('Button URL (https://...)', 'https://');
            if (!label || !url) return;
            insertTextAtCursor(e.target, ` [button:${label}](${url}) `);
        }

        if (e.target.classList.contains('add-sq-card-btn')) {
            const area = e.target.closest('.sidequest-content-area');
            if (!area) return;
            const wrap = document.createElement('div');
            wrap.className = 'sq-card-wrap';
            wrap.style.marginBottom = '10px';
            wrap.innerHTML = `<div style="display:flex; gap:10px; margin: 5px 0;"><input type="text" class="sq-card-title" placeholder="Card title (optional)" style="flex:1;"></div><div style="display:flex; gap:10px; margin: 5px 0;"><input type="text" class="sq-card-next-label" placeholder="Next label (optional)" style="flex:1;"><input type="text" class="sq-card-prev-label" placeholder="Previous label (optional)" style="flex:1;"></div><textarea class="sq-content" placeholder="Card content. You can paste URLs, add lists, images, etc." required></textarea>`;
            area.appendChild(wrap);
        }

        if (e.target.classList.contains('add-flip-card-btn')) {
            const container = e.target.previousElementSibling;
            const cardTemplate = document.getElementById('flip-card-template');
            container.appendChild(cardTemplate.content.cloneNode(true));
        }
    });

    function insertTextAtCursor(buttonElement, textToInsert) {
        // Prefer a textarea inside the sidequest content area, falling back to standard node textarea
        const sqArea = buttonElement.closest('.sidequest-content-area');
        let textarea = null;
        if (sqArea) {
            // Use the focused textarea if it's inside this area; otherwise the first card textarea
            const active = document.activeElement && sqArea.contains(document.activeElement) && document.activeElement.tagName === 'TEXTAREA' ? document.activeElement : null;
            textarea = active || sqArea.querySelector('textarea:focus') || sqArea.querySelector('.sq-card-wrap textarea') || sqArea.querySelector('textarea');
        } else {
            const labelWrap = buttonElement.closest('.label-with-button');
            if (labelWrap && labelWrap.nextElementSibling && labelWrap.nextElementSibling.tagName === 'TEXTAREA') {
                textarea = labelWrap.nextElementSibling;
            } else if (labelWrap) {
                const container = labelWrap.parentElement || document;
                textarea = container.querySelector('textarea');
            }
        }
        if (!textarea) return;
        const start = textarea.selectionStart ?? 0;
        const end = textarea.selectionEnd ?? 0;
        const text = textarea.value || '';
        textarea.value = text.substring(0, start) + textToInsert + text.substring(end);
        textarea.focus();
        const caret = start + textToInsert.length;
        textarea.selectionStart = textarea.selectionEnd = caret;
    }

    if (nodesContainer.children.length === 0) addNewNode();
    addNodeBtn.addEventListener('click', () => addNewNode());
    nodesContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('btn-remove')) e.target.closest('.node-card, .connection-row, .sidequest-row, .flip-card-row, .link-row').remove();
        else if (e.target.classList.contains('add-connection-btn')) addConnectionToNode(e.target.closest('.node-card'));
        else if (e.target.classList.contains('add-sidequest-btn')) addSideQuestToNode(e.target.closest('.node-card'));
        else if (e.target.classList.contains('add-link-btn')) addLinkToNode(e.target.closest('.node-card'));
        else if (e.target.classList.contains('add-node-above-btn')) {
            const currentCard = e.target.closest('.node-card');
            addNewNode(null, '', '', 'left', currentCard);
        }
        else if (e.target.classList.contains('add-node-below-btn')) {
            const currentCard = e.target.closest('.node-card');
            const next = currentCard.nextElementSibling;
            addNewNode(null, '', '', 'left', next);
        }
    });
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            try { parseAndRender(event.target.result); alert('Course successfully loaded!'); }
            catch (error) { console.error("Error parsing file:", error); alert("Could not parse file."); }
        };
        reader.readAsText(file); e.target.value = '';
    });
    generateBtn.addEventListener('click', () => {
        let finalOutput = '# Auto-generated by FlowScript Course Creator\n\n'; const sideQuestContentMap = new Map();
        document.querySelectorAll('.node-card').forEach(card => {
            const id = card.querySelector('.node-id').value;
            const title = card.querySelector('.node-title').value.replace(/\n/g, '<br>');
            const titleAlign = (card.querySelector('.node-title-align')?.value || 'left');
            const type = card.querySelector('.node-type').value;
            
            if (!id) return;
            
            let content = '';
            if (type === 'flip-cards') {
                const flipCards = [];
                const intro = card.querySelector('.flip-intro')?.value || '';
                card.querySelectorAll('.flip-card-row').forEach(row => {
                    const front = row.querySelector('.flip-card-front').value;
                    const back = row.querySelector('.flip-card-back').value;
                    if (front || back) {
                       flipCards.push(`[card]\nfront: ${front}\nback: ${back}`);
                    }
                });
                const cardsJoined = flipCards.join('\n[card-separator]\n');
                content = (intro && intro.trim().length)
                    ? `[intro]\n${intro.trim()}\n[/intro]\n${cardsJoined}`
                    : cardsJoined;
            } else {
                content = card.querySelector('.node-content').value;
            }

            const alignLine = (titleAlign === 'center') ? `title-align: center\n` : '';
            finalOutput += `id: ${id}\ntitle: ${title}\n${alignLine}type: ${type}\n---\n${content.trim()}\n---\n`;
            
            card.querySelectorAll('.connection-row').forEach(conn => { const text = conn.querySelector('.conn-text').value, target = conn.querySelector('.conn-target').value; if(text && target) finalOutput += `> ${text} -> ${target}\n`; });
            card.querySelectorAll('.sidequest-row').forEach(sq => {
                const btnText = sq.querySelector('.sq-btn-text').value, type = sq.querySelector('.sq-type').value, sqTitle = sq.querySelector('.sq-title').value;
                const nextLabel = (sq.querySelector('.sq-next-label').value || '').trim();
                const backLabel = (sq.querySelector('.sq-back-label').value || '').trim();
                const wraps = Array.from(sq.querySelectorAll('.sq-card-wrap'));
                const cards = wraps.map(w => {
                    const title = (w.querySelector('.sq-card-title').value || '').trim();
                    const n = (w.querySelector('.sq-card-next-label').value || '').trim();
                    const p = (w.querySelector('.sq-card-prev-label').value || '').trim();
                    const body = (w.querySelector('.sq-content').value || '').trim();
                    const meta = [];
                    if (title.length) meta.push(`[title: ${title}]`);
                    if (n.length) meta.push(`[next: ${n}]`);
                    if (p.length) meta.push(`[prev: ${p}]`);
                    return (meta.length ? meta.join('\n') + '\n' : '') + body;
                }).filter(v => v.length > 0);
                if (btnText && type && sqTitle) { 
                    finalOutput += `> ${btnText} -> [${type}:${sqTitle}]\n`; 
                    if (cards.length) {
                        const uniqueKey = `${type}:${sqTitle}`;
                        sideQuestContentMap.set(uniqueKey, { cards: cards.join('\n[sq-card-separator]\n'), nextLabel, backLabel });
                    }
                }
            });
            card.querySelectorAll('.link-row').forEach(link => {
                const btnText = link.querySelector('.link-btn-text').value;
                const url = link.querySelector('.link-url').value;
                const newTab = link.querySelector('.link-target-newtab').checked;
                if (btnText && url) {
                    const target = newTab ? 'newtab' : 'embed';
                    finalOutput += `> ${btnText} -> [link:${target}:${url}]\n`;
                }
            });
            finalOutput += '\n';
        });
        sideQuestContentMap.forEach((meta, uniqueKey) => { 
            const [type, title] = uniqueKey.split(':', 2);
            const opts = [];
            if (meta.nextLabel && meta.nextLabel.length) opts.push(`next=${meta.nextLabel}`);
            if (meta.backLabel && meta.backLabel.length) opts.push(`back=${meta.backLabel}`);
            const optsStr = opts.length ? `|${opts.join('|')}` : '';
            const content = typeof meta === 'string' ? meta : meta.cards;
            finalOutput += `[side-quest-content:${type}:${title}${optsStr}]\n---\n${content}\n---\n\n`; 
        });
        outputText.value = finalOutput.trim(); downloadBtn.style.display = 'inline-block'; alert('Course text generated!');
    });
    downloadBtn.addEventListener('click', () => {
        const textToSave = outputText.value; if (!textToSave) return alert("Generate text first!");
        const blob = new Blob([textToSave], { type: 'text/plain' }); const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = 'course-edited.txt';
        document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
    });
});
</script>

</body>
</html>