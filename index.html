<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Learning Flow Visualization</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --color-bg: #FAFAFA;
      --color-card-bg: #FFFFFF;
      --color-primary-text: #304642;
      --color-accent: #FF5A00;
      --color-visited-main: #304642;
      --color-visited-sidequest: #B4BDA3;
      --color-unvisited: #D5D5D5;
      --font-family: 'Poppins', sans-serif;
    }
    html, body {
      height: 100%; margin: 0; padding: 0; background: var(--color-bg); font-family: var(--font-family); color: var(--color-primary-text); overflow: hidden;
    }
    .container { display: flex; height: 100vh; width: 100vw; box-sizing: border-box; }
    #flow-map-container {
      width: 400px; min-width: 0; background: var(--color-bg); display: flex; flex-direction: column; position: relative; cursor: grab; flex-shrink: 0;
      transition: width 0.5s cubic-bezier(0.645, 0.045, 0.355, 1), padding 0.5s cubic-bezier(0.645, 0.045, 0.355, 1);
    }
    #flow-map-container.collapsed { width: 0 !important; padding: 0; border: none; }
    #flow-map-container:active { cursor: grabbing; }
    #flow-map-svg {
      width: 100%; height: 100%; display: block;
      background-image: radial-gradient(circle, #E0E0E0 1px, transparent 1px);
      background-size: 20px 20px;
    }
    #resizer { width: 8px; height: 100%; position: absolute; right: 0; top: 0; cursor: col-resize; background: transparent; z-index: 20; }
    #close-sidebar-btn {
      position: absolute; right: 10px; top: 50%; transform: translateY(-50%) scaleX(-1);
      padding: 8px 12px; background: var(--color-card-bg);
      border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; z-index: 30;
    }
    #close-sidebar-btn:hover { background: #f7f7f7; }
    #open-sidebar-btn {
      display: none; position: absolute; left: 10px; top: 50%; transform: translateY(-50%); padding: 8px 12px; background: var(--color-card-bg);
      border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; z-index: 30;
    }
    #open-sidebar-tip {
      position: absolute; left: 48px; top: 50%; transform: translateY(-50%) translateX(-8px);
      background: #333; color: #fff; padding: 8px 10px; border-radius: 8px; font-size: 0.9rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); opacity: 0; visibility: hidden; transition: opacity 0.28s ease, transform 0.28s ease;
      pointer-events: none; z-index: 31;
    }
    #open-sidebar-tip::before {
      content: ''; position: absolute; left: -8px; top: 50%; transform: translateY(-50%);
      border-width: 8px; border-style: solid; border-color: transparent #333 transparent transparent;
    }
    #open-sidebar-tip.visible { opacity: 1; visibility: visible; transform: translateY(-50%) translateX(0); }
    #tooltip {
      position: absolute; visibility: hidden; background-color: #333; color: #fff; padding: 8px 12px; border-radius: 6px;
      font-size: 0.9rem; pointer-events: none; transition: opacity 0.2s; opacity: 0; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    #tooltip .tooltip-title { font-weight: 600; }
    #tooltip .tooltip-type { font-size: 0.8rem; opacity: 0.8; margin-top: 4px; }
    
    #content-area {
        flex: 1 1 auto; display: flex; align-items: stretch; justify-content: flex-start;
        gap: 16px; padding: 72px; box-sizing: border-box; overflow: hidden;
    }
    #content-card {
      width: 100%; height: 100%; background: var(--color-card-bg); border-radius: 18px; box-shadow: 0 4px 32px 0 rgba(60,60,60,0.07);
      padding: 40px 36px 24px 36px; display: flex; flex-direction: column; overflow-y: auto; box-sizing: border-box;
    }
    #card-text-content { flex-grow: 1; padding-bottom: 24px; }
    #card-title { font-size: 2rem; font-weight: normal; margin-bottom: 24px; color: var(--color-primary-text); }
    #card-content { font-size: 1.1rem; color: var(--color-primary-text); white-space: pre-wrap; line-height: 1.5; overflow-wrap: break-word; }
    #card-content p { margin: 0 0 0.15em 0; }
    #card-content strong { font-weight: 600; }
    #card-content ul {
      list-style: none; /* Remove default styling */
      padding-left: 1em;
      margin: 1em 0;
    }
    /* Quote component */
    .quote-block { display: grid; grid-template-columns: 32px 1fr; gap: 12px; align-items: start; margin: 24px 0; }
    .quote-mark { color: var(--color-accent); font-weight: 700; font-size: 28px; line-height: 1; }
    .quote-text { font-style: italic; opacity: 0.9; }
    .quote-author { color: #8a8f87; font-size: 0.95rem; margin-top: 6px; }
    #card-content li {
      padding-left: 1.2em;
      position: relative;
      margin-bottom: 0.5em;
    }
    #card-content li::before {
      content: '•'; /* Use a solid bullet character */
      color: var(--color-primary-text); /* Use the main text color */
      font-weight: bold;
      font-size: 1.1em;
      position: absolute;
      left: 0;
      top: -0.1em; /* Fine-tune vertical alignment */
    }
    .content-images-container {
      display: flex; gap: 20px; justify-content: center; margin: 30px 0; flex-wrap: wrap; align-items: center;
    }
    .content-images-container img {
      max-width: 100%; height: auto; display: block;
    }
    .content-images-container .img-container {
        display: flex;
        justify-content: center;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 10px 25px rgba(0,0,0,0.08), 0 3px 8px rgba(0,0,0,0.08);
        background: #fff;
        flex: 1 1 auto;
    }
    /* Borderless media container */
    .content-images-container .img-container.no-frame,
    .content-with-stacked-images .stacked-images .img-container.no-frame {
        background: transparent;
        box-shadow: none;
        border-radius: 0;
    }
    .content-images-container .img-container.size-large,
    .content-images-container .size-large { max-width: 100%; flex-basis: 100%; }
    .content-images-container .size-x-small { max-width: 15%; flex-basis: 15%; }
    .content-images-container .size-small { max-width: 25%; flex-basis: 25%; }
    .content-images-container .size-medium { max-width: 50%; flex-basis: 50%; }
    /* Exact widths that account for the 20px gap between items */
    .content-images-container .size-third { flex: 0 0 calc((100% - 40px) / 3); max-width: calc((100% - 40px) / 3); }
    .content-images-container .size-fourth { flex: 0 0 calc((100% - 60px) / 4); max-width: calc((100% - 60px) / 4); }
    .content-images-container .img-container.size-large {
        flex-basis: 100%;
    }
    .content-images-container .size-x-small { max-width: 15%; flex-basis: 15%; }
    .content-images-container .size-small { max-width: 25%; flex-basis: 25%; }
    .content-images-container .size-medium { max-width: 50%; flex-basis: 50%; }
    .content-images-container .size-large { max-width: 100%; flex-basis: 100%; }

    /* Make videos fill their container, which handles sizing and shadows */
    .img-container video {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
        display: block;
    }
    /* Lottie container sizing */
    .img-container .lottie-anim {
        width: 100%;
        height: 100%;
        display: block;
    }

    /* Alignment for the container of a line of images */
    .content-images-container.align-left { justify-content: flex-start; }
    .content-images-container.align-center { justify-content: center; }
    .content-images-container.align-right { justify-content: flex-end; }
    
    /* Special layout for stacked images on the right */
    .content-with-stacked-images {
      display: flex; gap: 30px; align-items: center;
    }
    /* Optional top-aligned variant for stack-right layouts */
    .content-with-stacked-images.top-aligned {
      align-items: flex-start;
    }
    .content-with-stacked-images .text-content {
      flex: 1; /* Take up remaining space */
    }
    .content-with-stacked-images .stacked-images {
      display: flex; flex-direction: column; gap: 15px; flex-shrink: 0; max-width: clamp(320px, 45%, 800px);
      margin-top: 0; /* Align with top of text content */
      margin-left: auto; /* Always keep media anchored to the right */
    }
    .content-with-stacked-images .stacked-images img { display: block; }
    .content-with-stacked-images .stacked-images .img-container {
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 25px rgba(0,0,0,0.08), 0 3px 8px rgba(0,0,0,0.08);
      background: #fff;
    }
    /* Width sizing for stacked-right media */
    .content-with-stacked-images .stacked-images .size-x-small { max-width: 15%; flex-basis: 15%; }
    .content-with-stacked-images .stacked-images .size-small { max-width: 25%; flex-basis: 25%; }
    .content-with-stacked-images .stacked-images .size-medium { max-width: 50%; flex-basis: 50%; }
    .content-with-stacked-images .stacked-images .size-large { max-width: 100%; flex-basis: 100%; }
    .content-images-container.align-stack-right {
      margin: 0; /* Remove default margins for stacked layout */
    }

    /* --- Flip Card Styles (Overhauled for Simplicity & Robustness) --- */
    .flip-card-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        padding: 20px 0;
        /* By removing 'align-items: start', cards will stretch to equal height in each row */
    }
    .flip-card {
        display: grid; /* Use grid to stack front and back */
        grid-template-areas: "stack";
        cursor: pointer;
    }
    .flip-card-front, .flip-card-back {
        grid-area: stack; /* Place both front and back in the same grid area */
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        min-height: 150px; /* Set a minimum height but allow it to grow */
        box-sizing: border-box;
        font-size: 1rem;
        transition: opacity 0.4s ease;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    }
    .flip-card-front {
        background-color: #f8f9fa;
        color: var(--color-primary-text);
        opacity: 1;
        text-align: center;
        flex-direction: column; /* Stack title and subtitle vertically */
    }
    .flip-card-back {
        background-color: var(--color-card-bg);
        color: var(--color-primary-text);
        opacity: 0;
    }
    .flip-card.flipped .flip-card-front {
        opacity: 0;
    }
    .flip-card.flipped .flip-card-back {
        opacity: 1;
    }
    .flip-card-front p, .flip-card-back p {
        margin: 0;
    }
    /* --- End Flip Card Styles --- */
    
    #card-buttons {
        position: sticky;
        bottom: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 24px;
        padding: 12px 0;
        z-index: 2;
    }
    #card-buttons-left, #card-buttons-right {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
    }
    #card-buttons button {
      background: var(--color-accent); color: #fff; border: none; border-radius: 50px; padding: 10px 24px;
      font-size: 14px; font-family: var(--font-family); font-weight: 600; cursor: pointer; transition: background 0.2s, box-shadow 0.2s;
      box-shadow: 0 2px 8px 0 rgba(255,90,0,0.15);
    }
    #card-buttons button:hover { background: #e04e00; }

    /* Custom styles for main path navigation buttons */
    #card-buttons .btn-primary {
      background: #FF5A00; color: #fff; border: none; border-radius: 500px; padding: 10px 24px;
      font-size: 14px; font-family: var(--font-family); font-weight: 600; line-height: 1.2;
      display: inline-flex; align-items: center; gap: 12px; box-shadow: 0 2px 8px rgba(255,90,0,0.18);
      transition: background 0.2s, box-shadow 0.2s, transform 0.2s;
    }
    /* Chevron SVGs will be inserted in markup; no pseudo-element needed */
    #card-buttons .btn-primary:hover { background: #e04e00; box-shadow: 0 4px 12px rgba(255,90,0,0.28); transform: translateY(-1px); }
    #card-buttons .btn-primary svg { width: 10px; height: 16px; }

    /* Sidequest buttons (green) */
    #card-buttons .btn-sidequest {
      background: #304642; color: #fff; border: none; border-radius: 500px; padding: 10px 24px;
      font-size: 14px; font-family: var(--font-family); font-weight: 600; line-height: 1.2;
      display: inline-flex; align-items: center; gap: 12px; box-shadow: 0 2px 8px rgba(48,70,66,0.18);
      transition: background 0.2s, box-shadow 0.2s, transform 0.2s;
    }
    #card-buttons .btn-sidequest:hover { background: #2a3c39; box-shadow: 0 4px 12px rgba(48,70,66,0.28); transform: translateY(-1px); }

    #card-buttons .btn-prev {
      background: #fff; color: #8A8A8A; border: 1px solid #8A8A8A; border-radius: 500px; padding: 10px 24px;
      font-size: 14px; font-family: var(--font-family); font-weight: 600; line-height: 1.2;
      display: inline-flex; align-items: center; gap: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.06);
      transition: background 0.2s, box-shadow 0.2s, transform 0.2s, border-color 0.2s;
    }
    /* Chevron SVG will be inserted in markup; no pseudo-element needed */
    #card-buttons .btn-prev:hover { background: #fff; border-color: #6f6f6f; box-shadow: 0 4px 12px rgba(0,0,0,0.10); transform: translateY(-1px); }
    #card-buttons .btn-prev svg { width: 10px; height: 16px; }

    .resource-link-btn {
      display: inline-flex; align-items: center; justify-content: center; gap: 10px; margin-top: 20px; padding: 12px 28px;
      background-color: var(--color-accent); color: white; text-decoration: none; border-radius: 50px; font-weight: 600;
      box-shadow: 0 2px 8px 0 rgba(255,90,0,0.2); transition: all 0.2s;
    }
    .resource-link-btn:hover { background-color: #e04e00; transform: translateY(-2px); box-shadow: 0 4px 12px 0 rgba(255,90,0,0.3); }

    #embed-panel { width: 48%; min-width: 420px; height: 100%; background: var(--color-card-bg); border-radius: 18px;
      box-shadow: 0 4px 32px 0 rgba(60,60,60,0.07); display: none; flex-direction: column; overflow: hidden; }
    #embed-panel.visible { display: flex; }
    #embed-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 14px; border-bottom: 1px solid #eee; gap: 8px; }
    #embed-title { font-weight: 600; }
    #embed-actions { display: flex; align-items: center; gap: 8px; }
    #embed-close { background: transparent; border: none; border-radius: 6px; width: 28px; height: 28px; cursor: pointer; font-size: 18px; line-height: 28px; }
    #embed-open-external { background: var(--color-accent); color: #fff; border: none; border-radius: 8px; padding: 6px 10px; cursor: pointer; font-weight: 600; }
    #embed-iframe { flex: 1 1 auto; width: 100%; border: 0; }
    
    /* Draggable divider between content and embed */
    #content-embed-resizer {
      width: 8px;
      cursor: col-resize;
      background: transparent;
      position: relative;
      z-index: 5;
      display: none; /* only visible when embed is visible */
    }
    #content-embed-resizer.visible { display: block; }
    #content-embed-resizer::after {
      content: '';
      position: absolute;
      top: 0; bottom: 0; left: 2px; right: 2px;
      border-radius: 2px;
      background: rgba(0,0,0,0.06);
      transition: background 0.2s;
    }
    #content-embed-resizer:hover::after { background: rgba(0,0,0,0.12); }

    .link { stroke: #999; stroke-opacity: 0.6; }
    .link.visited-main, .link.visited-sidequest { stroke: var(--color-visited-main); stroke-width: 2.5px; }
    .link.visited-sidequest { stroke-dasharray: 4 4; }
    .node circle {
        transition: all 0.2s; fill: var(--color-unvisited); cursor: pointer;
    }
    .node:hover circle { transform: scale(1.1); }
    .node.unvisited circle { fill: var(--color-unvisited); }
    .node.visited-main circle { fill: var(--color-visited-main); }
    .node.visited-sidequest circle { fill: var(--color-visited-sidequest); }
    .node.active circle { fill: var(--color-accent); filter: drop-shadow(0 0 10px var(--color-accent)); r: 15 !important; }
    
    .img-container {
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 25px rgba(0,0,0,0.08), 0 3px 8px rgba(0,0,0,0.08);
      background: #fff;
    }
    
    @media (max-width: 900px) {
        .flip-card-grid {
            grid-template-columns: 1fr;
        }
        /* Media query for responsive is unchanged */
    }

    /* Sidebar open: give more separation and slightly narrower text column */
    #flow-map-container:not(.collapsed) ~ #content-area #content-card .content-with-stacked-images { gap: 40px; }
    #flow-map-container:not(.collapsed) ~ #content-area #content-card .content-with-stacked-images .text-content { flex: 0 1 52ch; max-width: 52ch; }
    #flow-map-container:not(.collapsed) ~ #content-area #content-card .content-with-stacked-images .stacked-images { max-width: clamp(320px, 48%, 760px); }

    /* Sidebar closed: add more side padding on the card and bring text/media closer */
    #flow-map-container.collapsed ~ #content-area #content-card { padding-left: 56px; padding-right: 56px; }
    #flow-map-container.collapsed ~ #content-area #content-card .content-with-stacked-images { gap: 22px; }
    #flow-map-container.collapsed ~ #content-area #content-card .content-with-stacked-images .text-content { flex: 1 1 70ch; max-width: 70ch; }
    #flow-map-container.collapsed ~ #content-area #content-card .content-with-stacked-images .stacked-images { max-width: clamp(340px, 44%, 820px); }
  </style>
</head>
<body>
  <div class="container">
    <div id="flow-map-container" class="collapsed">
      <svg id="flow-map-svg"></svg>
      <div id="tooltip"></div>
      <div id="resizer"></div>
      <button id="close-sidebar-btn" title="Close Flow Map">➔</button>
    </div>
    <div id="content-area">
        <button id="open-sidebar-btn" title="Open Flow Map">➔</button>
        <div id="open-sidebar-tip" role="status" aria-live="polite">Click to open flow path</div>
        <div id="content-card">
            <div id="card-text-content">
                <h2 id="card-title">Loading...</h2>
                <div id="card-content"></div>
            </div>
            <div id="card-buttons"></div>
        </div>

        <div id="content-embed-resizer" aria-hidden="true"></div>

        <div id="embed-panel" aria-label="Embedded resource panel">
          <div id="embed-header">
            <span id="embed-title">Resource</span>
            <div id="embed-actions">
              <button id="embed-open-external" title="Open in new tab">Open in new tab</button>
              <button id="embed-close" title="Close">×</button>
            </div>
          </div>
          <iframe id="embed-iframe" allow="fullscreen; clipboard-write; autoplay; storage-access"></iframe>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
  <script src="https://unpkg.com/lottie-web@5.12.2/build/player/lottie.min.js"></script>
  <script>
    function renderContent(element, text, nodeType = 'main') {
        if (nodeType === 'flip-cards') {
            renderFlipCards(element, text);
            return;
        }
        let content = text || '';
        // Strip any leading header tags like [title:], [next:], [prev:] that may remain in card content
        content = content.replace(/^(?:\s*\[(?:title|next|prev):[^\]]+\]\s*\n)+/i, '');
        // Clear any previous resource metadata on this element
        try {
          element.removeAttribute('data-resource-url');
          element.removeAttribute('data-resource-title');
          element.removeAttribute('data-buttons');
          element.innerHTML = '';
        } catch (_) {}

        // Detect and render [quote] blocks first
        const quoteRegex = /\[quote\][\s\S]*?\[\/quote\]/g;
        const hasQuote = quoteRegex.test(content);
        if (hasQuote) {
          const parts = content.split(quoteRegex);
          const quotes = content.match(quoteRegex) || [];
          // Render non-quote parts normally and quotes as components, sequentially
          let html = '';
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (part && part.trim()) {
              const temp = document.createElement('div');
              renderContentNormal(temp, part.trim());
              html += temp.innerHTML;
            }
            const q = quotes[i];
            if (q) {
              const textMatch = q.match(/text:\s*(.*)/);
              const authorMatch = q.match(/author:\s*(.*)/);
              const qText = textMatch ? textMatch[1].trim() : '';
              const qAuthor = authorMatch ? authorMatch[1].trim() : '';
              html += `<div class="quote-block"><div class="quote-mark">❝</div><div><div class="quote-text">${qText}</div>${qAuthor ? `<div class="quote-author">— ${qAuthor}</div>` : ''}</div></div>`;
            }
          }
          element.innerHTML = html;
          return;
        }

        // Extract inline button syntax: [button:Label](https://...)
        const buttonRegex = /\[button:([^\]]+)\]\((https?:\/\/[^\s)]+)\)/gi;
        const buttonDefs = [];
        let strippedContent = content.replace(buttonRegex, (m, label, url) => {
          buttonDefs.push({ buttonText: label.trim(), url: url.trim() });
          return '';
        }).trim();

        // Normalize alias syntax: [image/...](file) or [video/...](file) -> ![image/...](file)
        strippedContent = strippedContent.replace(/\[(image|video|lottie)([^\]]*)\]\(([^)]+)\)/gi, '![$1$2]($3)');

        // --- Handle special content types first (YouTube, links) ---
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
        const youtubeMatch = strippedContent.match(youtubeRegex);
        if (youtubeMatch) {
            const videoId = youtubeMatch[1];
            element.innerHTML = `<div style="position: relative; width: 100%; padding-top: 56.25%; background: #eee; border-radius: 8px; overflow: hidden;"><iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" src="https://www.youtube.com/embed/${videoId}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`;
            if (buttonDefs.length) element.setAttribute('data-buttons', JSON.stringify(buttonDefs));
            return;
        }
        if (strippedContent.startsWith('http://') || strippedContent.startsWith('https://')) {
            // Store URL on the content element; we'll render the button in the buttons area instead
            element.innerHTML = '';
            element.setAttribute('data-resource-url', strippedContent);
            element.setAttribute('data-resource-title', 'Open Resource');
            if (buttonDefs.length) element.setAttribute('data-buttons', JSON.stringify(buttonDefs));
            return;
        }
 
        // Check if we have any stacked-right images
        const imageRegex = /!\[(.*?)\]\(([^)\s]+)\)/g;
        const allImages = [...strippedContent.matchAll(imageRegex)];
        const hasStackedMedia = allImages.some(img => {
            const attrs = img[1].split('/').slice(1);
            return attrs.some(attr => attr.includes('align:stack-right') || attr.includes('align:stack-right-top'));
        });
 
        if (hasStackedMedia) {
            renderContentWithStackedImages(element, strippedContent);
        } else {
            renderContentNormal(element, strippedContent);
        }
        if (buttonDefs.length) element.setAttribute('data-buttons', JSON.stringify(buttonDefs));
    }

    function renderContentWithStackedImages(element, content) {
        const lines = content.split('\n');
        let textHtml = '';
        let stackedMedia = [];
        let inList = false;
        const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

        for (const line of lines) {
            const trimmedLine = line.trim();
            const isListItem = trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ') || trimmedLine.startsWith('-');

            const mediaRegex = /!\[(.*?)\]\(([^)\s]+)\)/g;
            const mediaItems = [...line.matchAll(mediaRegex)];

            if (mediaItems.length > 0) {
                // Check if this line has stacked-right media
                let hasStackedOnThisLine = false;
                mediaItems.forEach(match => {
                    const allData = match[1].split('/');
                    const attributes = allData.slice(1);
                    const isStacked = attributes.some(attr => attr.includes('align:stack-right'));
                    
                    if (isStacked) {
                        hasStackedOnThisLine = true;
                        const typeAndAlt = allData[0].split(':');
                        const mediaType = typeAndAlt[0];
                        const isVideo = mediaType === 'video';
                        const fileRef = match[2];
                        const isLottie = mediaType === 'lottie' || /\.json(\?|$)/i.test(fileRef);
                        const altText = (isVideo || isLottie) ? typeAndAlt.slice(1).join(':').trim() : allData[0].trim();
                        
                        const v = (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? Date.now() : '1.0';
                        const src = `images/${match[2]}?v=${v}`;
                        
                        let sizeClass = 'size-medium';
                        let style = '';
                        let frameClass = '';
                        attributes.forEach(attr => {
                            const [key, value] = attr.split(':');
                            if (key.trim() === 'size') {
                                const sizeValue = value.trim();
                                if (sizeValue.endsWith('px')) {
                                    style = `height: ${sizeValue}; width: auto;`;
                                    sizeClass = '';
                                } else {
                                    sizeClass = `size-${sizeValue}`;
                                }
                            } else if (key.trim() === 'frame' || key.trim() === 'border' || key.trim() === 'style') {
                                const v = (value || '').trim().toLowerCase();
                                if (v === 'none' || v === 'no' || v === 'off' || v === 'plain' || v === '0') {
                                    frameClass = 'no-frame';
                                }
                            }
                        });
                        
                        if (isVideo) {
                            stackedMedia.push(`<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><video autoplay loop muted playsinline style=\"width:100%;height:auto;\" src=\"${src}\" title=\"${altText}\"></video></div>`);
                        } else if (isLottie) {
                            stackedMedia.push(`<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><div class=\"lottie-anim\" data-src=\"${src}\" data-loop=\"true\" data-autoplay=\"true\" aria-label=\"${altText}\"></div></div>`);
                        } else {
                            stackedMedia.push(`<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><img src=\"${src}\" alt=\"${altText}\" style=\"${style}\"></div>`);
                        }
                    }
                });

                // If line has non-stacked media, process them normally
                if (!hasStackedOnThisLine) {
                    let combinedAttrs = [];
                    mediaItems.forEach(match => {
                        const allData = match[1].split('/');
                        const attributes = allData.slice(1);
                        combinedAttrs = combinedAttrs.concat(attributes);
                    });

                    let alignClass = 'align-center';
                    combinedAttrs.forEach(attr => {
                        const [key, value] = attr.split(':');
                        if (key === 'align') {
                            alignClass = `align-${value.trim()}`;
                        }
                    });

                    let mediaHtml = `<div class="content-images-container ${alignClass}">`;
                    mediaItems.forEach(match => {
                        const allData = match[1].split('/');
                        const typeAndAlt = allData[0].split(':');
                        const mediaType = typeAndAlt[0];
                        const isVideo = mediaType === 'video';
                        const fileRef = match[2];
                        const isLottie = mediaType === 'lottie' || /\.json(\?|$)/i.test(fileRef);
                        const altText = (isVideo || isLottie) ? typeAndAlt.slice(1).join(':').trim() : allData[0].trim();
                        const attributes = allData.slice(1);
                        const v = (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? Date.now() : '1.0';
                        const src = `images/${match[2]}?v=${v}`;
                        
                        let sizeClass = 'size-large';
                        let style = '';
                        let frameClass = '';
                        attributes.forEach(attr => {
                            const [key, value] = attr.split(':');
                            if (key.trim() === 'size') {
                                const sizeValue = value.trim();
                                if (sizeValue.endsWith('px')) {
                                    style = `height: ${sizeValue}; width: auto;`;
                                    sizeClass = '';
                                } else {
                                    sizeClass = `size-${sizeValue}`;
                                }
                            } else if (key.trim() === 'frame' || key.trim() === 'border' || key.trim() === 'style') {
                                const v = (value || '').trim().toLowerCase();
                                if (v === 'none' || v === 'no' || v === 'off' || v === 'plain' || v === '0') {
                                    frameClass = 'no-frame';
                                }
                            }
                        });
                        if (isVideo) {
                            mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><video autoplay loop muted playsinline style=\"width:100%;height:auto;\" src=\"${src}\" title=\"${altText}\"></video></div>`;
                        } else if (isLottie) {
                            mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><div class=\"lottie-anim\" data-src=\"${src}\" data-loop=\"true\" data-autoplay=\"true\" aria-label=\"${altText}\"></div></div>`;
                        } else {
                            mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><img src=\"${src}\" alt=\"${altText}\" style=\"${style}\"></div>`;
                        }
                    });
                    mediaHtml += '</div>';
                    textHtml += mediaHtml;
                }
            } else if (isListItem) {
                if (!inList) {
                    textHtml += '<ul>';
                    inList = true;
                }
                const listItemContent = processBold(trimmedLine.startsWith('- ') ? trimmedLine.substring(2) : trimmedLine.substring(1));
                textHtml += `<li>${listItemContent}</li>`;
            } else {
                if (inList) {
                    textHtml += '</ul>';
                    inList = false;
                }
                if (trimmedLine === '' && textHtml.length > 0) {
                    textHtml += '<p> </p>';
                } else if (trimmedLine !== '') {
                    textHtml += `<p>${processBold(line)}</p>`;
                }
            }
        }

        if (inList) {
            textHtml += '</ul>';
        }

        // Create the layout with text on left and stacked images on right
        const stackedMediaHtml = stackedMedia.length > 0 ? 
            `<div class="stacked-images">${stackedMedia.join('')}</div>` : '';

        // If any stacked media used, default container exists. Allow optional top alignment:
        // Use `align:stack-right-top` or `valign:top` on any stacked media item to activate.
        const shouldTopAlign = /align:stack-right-top|valign:top/i.test(content);

        element.innerHTML = `
            <div class="content-with-stacked-images${shouldTopAlign ? ' top-aligned' : ''}">
                <div class="text-content">${textHtml}</div>
                ${stackedMediaHtml}
            </div>
        `;
        initLottieWithin(element);
    }

    function renderContentNormal(element, content) {
        let html = '';
        const lines = content.split('\n');
        let inList = false;
        const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

        for (const line of lines) {
            const trimmedLine = line.trim();
            const isListItem = trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ') || trimmedLine.startsWith('-');

            if (isListItem) {
                if (!inList) {
                    html += '<ul>';
                    inList = true;
                }
                const listItemContent = processBold(trimmedLine.startsWith('- ') ? trimmedLine.substring(2) : trimmedLine.substring(1));
                html += `<li>${listItemContent}</li>`;
            } else {
                if (inList) {
                    html += '</ul>';
                    inList = false;
                }

                const imageRegex = /!\[(.*?)\]\(([^)\s]+)\)/g;
                const mediaItems = [...line.matchAll(imageRegex)];

                if (mediaItems.length > 0) {
                    let combinedAttrs = [];
                    mediaItems.forEach(imgMatch => {
                        const allData = imgMatch[1].split('/');
                        const attributes = allData.slice(1);
                        combinedAttrs = combinedAttrs.concat(attributes);
                    });

                    let alignClass = 'align-center';
                    combinedAttrs.forEach(attr => {
                        const [key, value] = attr.split(':');
                        if (key === 'align') {
                            alignClass = `align-${value.trim()}`;
                        }
                    });

                    let mediaHtml = `<div class="content-images-container ${alignClass}">`;

                    mediaItems.forEach(match => {
                        const allData = match[1].split('/');
                        const typeAndAlt = allData[0].split(':');
                        const mediaType = typeAndAlt[0];
                        const isVideo = mediaType === 'video';
                        const fileRef = match[2];
                        const isLottie = mediaType === 'lottie' || /\.json(\?|$)/i.test(fileRef);
                        const altText = (isVideo || isLottie) ? typeAndAlt.slice(1).join(':').trim() : allData[0].trim();
                        const attributes = allData.slice(1);
                        const v = (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? Date.now() : '1.0';
                        const src = `images/${match[2]}?v=${v}`;
                        
                        let sizeClass = 'size-large';
                        let style = '';
                        let frameClass = '';

                        attributes.forEach(attr => {
                            const [key, value] = attr.split(':');
                            if (key.trim() === 'size') {
                                const sizeValue = value.trim();
                                if (sizeValue.endsWith('px')) {
                                    style = `height: ${sizeValue}; width: auto;`;
                                    sizeClass = '';
                                } else {
                                    sizeClass = `size-${sizeValue}`;
                                }
                            } else if (key.trim() === 'frame' || key.trim() === 'border' || key.trim() === 'style') {
                                const v = (value || '').trim().toLowerCase();
                                if (v === 'none' || v === 'no' || v === 'off' || v === 'plain' || v === '0') {
                                    frameClass = 'no-frame';
                                }
                            }
                        });
                        if (isVideo) {
                           mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><video autoplay loop muted playsinline style=\"width:100%;height:auto;\" src=\"${src}\" title=\"${altText}\"></video></div>`;
                        } else if (isLottie) {
                           mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><div class=\"lottie-anim\" data-src=\"${src}\" data-loop=\"true\" data-autoplay=\"true\" aria-label=\"${altText}\"></div></div>`;
                        } else {
                           mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><img src=\"${src}\" alt=\"${altText}\" style=\"${style}\"></div>`;
                        }
                    });
                    mediaHtml += '</div>';
                    html += mediaHtml;
                } else if (trimmedLine === '' && html.length > 0) {
                    html += '<p> </p>';
                } else if (trimmedLine !== '') {
                    html += `<p>${processBold(line)}</p>`;
                }
            }
        }

        if (inList) {
            html += '</ul>'; // Close any list that's still open
        }

        element.innerHTML = html;
        initLottieWithin(element);
    }

    function initLottieWithin(root) {
        if (!window.lottie || !root) return;
        const nodes = root.querySelectorAll('.lottie-anim:not([data-lottie-initialized])');
        nodes.forEach(el => {
            const path = el.getAttribute('data-src');
            if (!path) return;
            // Use top-aligned aspect ratio inside stacked-right columns to avoid visual downward offset
            const isStackedRight = !!el.closest('.stacked-images');
            const preserve = isStackedRight ? 'xMinYMin meet' : 'xMidYMid meet';
            window.lottie.loadAnimation({
                container: el,
                renderer: 'svg',
                loop: el.getAttribute('data-loop') !== 'false',
                autoplay: el.getAttribute('data-autoplay') !== 'false',
                path,
                rendererSettings: { preserveAspectRatio: preserve, progressiveLoad: true }
            });
            el.setAttribute('data-lottie-initialized', '1');
        });
    }

    function renderFlipCards(element, text) {
        const cardsData = [];
        // Split cards by the new, unique separator
        let introHtml = '';
        let working = text || '';
        const introMatch = working.match(/\[intro\]\n([\s\S]*?)\n\[\/intro\]\n?/);
        if (introMatch) {
            const introText = introMatch[1].trim();
            const temp = document.createElement('div');
            renderContentNormal(temp, introText);
            introHtml = temp.innerHTML;
            working = working.replace(introMatch[0], '');
        }
        const cardBlocks = working.split('[card-separator]');
        const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        cardBlocks.forEach(block => {
            const trimmedBlock = block.trim();
            if (!trimmedBlock.startsWith('[card]')) return;

            let front = 'Click to reveal';
            let back = '';
            
            const lines = trimmedBlock.split('\n').slice(1); // Skip the [card] line
            let currentKey = '';
            let contentBuffer = '';

            lines.forEach(line => {
                const frontMatch = line.match(/^front:\s*(.*)/);
                const backMatch = line.match(/^back:\s*(.*)/);

                if (frontMatch) {
                    if (currentKey === 'back') { // Finished back content
                        back = contentBuffer.trim();
                        contentBuffer = '';
                    }
                    currentKey = 'front';
                    contentBuffer = frontMatch[1];
                } else if (backMatch) {
                    if (currentKey === 'front') { // Finished front content
                        front = contentBuffer.trim();
                        contentBuffer = '';
                    }
                    currentKey = 'back';
                    contentBuffer = backMatch[1];
                } else {
                    contentBuffer += '\n' + line;
                }
            });

            // Capture the last piece of content
            if (currentKey === 'front') {
                front = contentBuffer.trim();
            } else if (currentKey === 'back') {
                back = contentBuffer.trim();
            }

            // Use default if front is empty
            if (!front) {
                front = 'Click to reveal';
            }

            cardsData.push({ front, back });
        });

        let html = '';
        if (introHtml) {
            html += `<div style="margin-bottom: 12px;">${introHtml}</div>`;
        }
        html += '<div class="flip-card-grid">';
        cardsData.forEach(card => {
            // New logic to handle title and subtitle for the front of the card
            const frontParts = card.front.split('\n');
            const frontTitle = frontParts[0];
            const frontSubtitle = frontParts.slice(1).join('<br>');

            let frontHtml = `<p><strong>${processBold(frontTitle)}</strong></p>`;
            if (frontSubtitle) {
                frontHtml += `<p style="font-size: 0.8em; opacity: 0.7; margin-top: 8px;">${processBold(frontSubtitle)}</p>`;
            }

            html += `
                <div class="flip-card" onclick="this.classList.toggle('flipped')">
                    <div class="flip-card-front">
                        ${frontHtml}
                    </div>
                    <div class="flip-card-back">
                        <p>${processBold(card.back)}</p>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        element.innerHTML = html;
    }

    function openInEmbed(url, title = 'Resource') {
      const panel = document.getElementById('embed-panel');
      const iframe = document.getElementById('embed-iframe');
      const titleEl = document.getElementById('embed-title');
      const resizer = document.getElementById('content-embed-resizer');
      const contentCard = document.getElementById('content-card');
      if (!panel || !iframe) { window.open(url, '_blank'); return; }
      titleEl.textContent = title;
      iframe.src = url;
      panel.classList.add('visible');
      if (resizer) resizer.classList.add('visible');
      // Ensure we have sensible initial split if not set yet
      if (contentCard && !contentCard.style.width) {
        contentCard.style.width = '50%';
      }
      if (!panel.style.width) {
        panel.style.width = '50%';
      }
    }

    function handleResourceClick(e, url, title) {
      if (e && (e.metaKey || e.ctrlKey || e.shiftKey || e.button === 1)) {
        window.open(url, '_blank');
        return false;
      }
      try {
        const parsed = new URL(url, window.location.href);
        const host = parsed.hostname || '';
        const isTargetInact = host.endsWith('inactnow.io');
        const isCurrentInact = (window.location.hostname || '').endsWith('inactnow.io');
        // If cross-site relative to inactnow.io, open in new tab to avoid cookie blocking; if same-site, keep in embed
        if (isTargetInact && !isCurrentInact) {
          window.open(url, '_blank');
          return false;
        }
      } catch (_) { /* ignore URL parse errors and fallback to embed */ }
      openInEmbed(url, title || 'Resource');
      return false;
    }

    document.addEventListener('DOMContentLoaded', () => {
             const closeBtn = document.getElementById('embed-close');
      const openExternalBtn = document.getElementById('embed-open-external');
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          const panel = document.getElementById('embed-panel');
          const iframe = document.getElementById('embed-iframe');
          const resizer = document.getElementById('content-embed-resizer');
          const contentCard = document.getElementById('content-card');
          if (iframe) iframe.src = 'about:blank';
          if (panel) panel.classList.remove('visible');
          if (resizer) resizer.classList.remove('visible');
          // Reset widths so the info-card returns to full size
          if (contentCard) contentCard.style.width = '';
          if (panel) panel.style.width = '';
        });
      }
      if (openExternalBtn) {
        openExternalBtn.addEventListener('click', () => {
          const iframe = document.getElementById('embed-iframe');
          const url = iframe && iframe.src ? iframe.src : null;
          if (url) window.open(url, '_blank');
        });
      }

      // Drag-to-resize between content and embed
      const resizer = document.getElementById('content-embed-resizer');
      const contentArea = document.getElementById('content-area');
      const contentCard = document.getElementById('content-card');
      const embedPanel = document.getElementById('embed-panel');
      let isDragging = false;

      function onPointerDown(e) {
        if (!embedPanel.classList.contains('visible')) return;
        isDragging = true;
        document.body.style.cursor = 'col-resize';
        e.preventDefault();
      }
      function onPointerMove(e) {
        if (!isDragging) return;
        const containerRect = contentArea.getBoundingClientRect();
        const minLeft = containerRect.left + 300; // min width for content card
        const maxLeft = containerRect.right - 420; // min width for embed panel
        let x = e.clientX;
        if (x < minLeft) x = minLeft;
        if (x > maxLeft) x = maxLeft;
        const leftWidth = x - containerRect.left;
        const rightWidth = containerRect.right - x;
        contentCard.style.width = leftWidth + 'px';
        embedPanel.style.width = rightWidth + 'px';
      }
      function onPointerUp() {
        if (!isDragging) return;
        isDragging = false;
        document.body.style.cursor = 'default';
      }

      if (resizer) {
        resizer.addEventListener('mousedown', onPointerDown);
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        // touch support
        resizer.addEventListener('touchstart', (e) => onPointerDown(e.touches[0]));
        window.addEventListener('touchmove', (e) => onPointerMove(e.touches[0]));
        window.addEventListener('touchend', onPointerUp);
      }
    });

    // --- START: NEW, MORE ROBUST PARSER ---
    function parseFlowScript(text) {
        const sideQuestContentMap = new Map();
        const mainNodes = [];
        let currentBlock = null;

        // First pass to extract side quest content blocks, which are self-contained
        const sqRegex = /\[side-quest-content:([^\]]+)\]\s*\n---\n([\s\S]*?)\n---/g;
        let remainingText = text.replace(sqRegex, (match, fullType, content) => {
            // fullType can be like "type:title|next=...|back=..."
            const firstColon = fullType.indexOf(':');
            const type = firstColon >= 0 ? fullType.slice(0, firstColon).trim() : fullType.trim();
            const rest = firstColon >= 0 ? fullType.slice(firstColon + 1) : '';
            const barIdx = rest.indexOf('|');
            const title = (barIdx >= 0 ? rest.slice(0, barIdx) : rest).trim();
            const optsStr = barIdx >= 0 ? rest.slice(barIdx + 1) : '';
            const opts = {};
            optsStr.split('|').forEach(p => {
                const [k, ...vparts] = p.split('=');
                if (!k || vparts.length === 0) return;
                opts[k.trim()] = vparts.join('=').trim();
            });
            const raw = (content || '').trim();
            const partsArr = raw.length ? raw.split(/\n\[sq-card-separator\]\n/) : [''];
            const cardObjs = partsArr.map(p => {
                let t = p.trim();
                let nextLabel = '';
                let prevLabel = '';
                const lines = t.split('\n');
                while (lines.length && /^\[(next|prev):/.test(lines[0].trim())) {
                    const m = lines.shift().trim().match(/^\[(next|prev):\s*(.+?)\]$/);
                    if (m) {
                        if (m[1] === 'next') nextLabel = m[2]; else prevLabel = m[2];
                    } else { break; }
                }
                return { content: lines.join('\n').trim(), nextLabel, prevLabel };
            });
            const key = title ? `${type}:${title}` : type;
            sideQuestContentMap.set(key, { cards: cardObjs, nextLabel: opts.next || '', backLabel: opts.back || '' });
            return ''; // Remove the block from the text
        });

        // Second, line-by-line pass for main nodes
        const lines = remainingText.split('\n');
        let isContent = false;
        
        for (const line of lines) {
            if (line.trim().startsWith('id:')) {
                // Finish previous node before starting a new one
                if (currentBlock) mainNodes.push(currentBlock);
                currentBlock = { connections: {}, sideQuests: [] };
                isContent = false;
            }

            if (!currentBlock) continue;

            if (line.trim() === '---') {
                isContent = !isContent;
                continue;
            }

            if (isContent) {
                currentBlock.content = (currentBlock.content || '') + line + '\n';
            } else {
                if (line.startsWith('>')) {
                    const mainMatch = line.match(/>\s*(.+?)\s*->\s*(\d+)/);
                    const sqMatch = line.match(/>\s*(.+?)\s*->\s*\[(video|now|case):(.+?)\]/);
                    const linkMatch = line.match(/>\s*(.+?)\s*->\s*\[link:(newtab|embed)?:?(.+?)\]/);
                    if (mainMatch) {
                        currentBlock.connections[mainMatch[1].trim()] = parseInt(mainMatch[2]);
                    } else if (sqMatch) {
                        const [, buttonText, type, title] = sqMatch;
                        // Try multiple matching strategies for content lookup
                        let meta = sideQuestContentMap.get(`${type}:${title}`);
                        
                        if (!meta) {
                            // Try to find content by partial title match (for legacy compatibility)
                            for (const [key, value] of sideQuestContentMap.entries()) {
                                if (key.startsWith(`${type}:`)) {
                                    const keyTitle = key.split(':', 2)[1];
                                    // Check if either title contains the other (partial match)
                                    if (title.includes(keyTitle) || keyTitle.includes(title)) {
                                        meta = value;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (!meta) {
                            // Final fallback to type-only match
                            meta = sideQuestContentMap.get(type) || { cards: [''], nextLabel: '', backLabel: '' };
                        }
                        
                        const cards = Array.isArray(meta) ? meta : (meta.cards || ['']);
                        const nextLabel = meta.nextLabel || '';
                        const backLabel = meta.backLabel || '';
                        currentBlock.sideQuests.push({ type, title, buttonText, cards, nextLabel, backLabel });
                    } else if (linkMatch) {
                        const [, buttonText, targetOpt, url] = linkMatch;
                        if (!currentBlock.links) currentBlock.links = [];
                        currentBlock.links.push({ buttonText: buttonText.trim(), url: url.trim().replace(/\]$/, ''), target: (targetOpt || 'newtab').trim() });
                    }
                } else {
                    const [key, ...valueParts] = line.split(':');
                    if (valueParts.length > 0) {
                        const value = valueParts.join(':').trim();
                        if (key.trim() === 'title-align') { currentBlock['title-align'] = value.toLowerCase(); continue; }
                        currentBlock[key.trim()] = key.trim() === 'id' ? parseInt(value) : value;
                    }
                }
            }
        }
        // Add the last node to the array
        if (currentBlock) mainNodes.push(currentBlock);

        // Clean up the content for each node
        mainNodes.forEach(node => {
            if (node.content) node.content = node.content.trim();
        });
        
        return mainNodes;
    }
    // --- END: NEW, MORE ROBUST PARSER ---
    
    // The main execution block (no changes needed here)
    (async function() {
        let courseData;
        try {
            const urlParams = new URLSearchParams(window.location.search);
            const courseFile = urlParams.get('course') || 'Intro-2.txt';
            const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            // Always bust caches to avoid GitHub Pages serving stale assets after deploys
            const cacheParam = Date.now();
            const requestUrl = `courses/${courseFile}?v=${cacheParam}`;
            const response = await fetch(requestUrl);
            if (!response.ok) throw new Error(`Failed to fetch ${requestUrl} (status ${response.status})`);
            const text = await response.text();
            courseData = parseFlowScript(text);
            if (!courseData || courseData.length === 0) { throw new Error("Parsing resulted in no valid course data."); }
        } catch (error) {
            console.error('Error loading or parsing course file:', error);
            document.getElementById('card-title').textContent = 'Error';
            document.getElementById('card-content').innerHTML = `Could not load the course. ${String(error && error.message || error)}. <br/>Tip: hard refresh (Ctrl/Cmd+Shift+R) if this was just deployed.`;
            return;
        }

        const firstNode = courseData.find(n => n && n.id != null);
        let activeNodeId = String(firstNode ? firstNode.id : '1'); let visitedNodes = new Set([activeNodeId]);
        let wasSidebarClosedBeforeSideQuest = false; // For auto-opening/closing on side quests
        const mainPathHistory = [activeNodeId]; let skipHistoryPush = false;
        const hasD3 = (typeof window !== 'undefined') && (typeof window.d3 !== 'undefined');
        let svgContainer, svg, g, tooltip, node, link, zoom, simulation;
        const d3Nodes = [], d3Links = [], nodeById = new Map();
        if (hasD3) {
          svgContainer = d3.select('#flow-map-container'); svg = d3.select('#flow-map-svg'); g = svg.append('g'); tooltip = d3.select('#tooltip');
        }

        courseData.forEach(mainNodeData => {
            if (!mainNodeData.id) return; // Skip invalid nodes
            const mainNode = { ...mainNodeData, id: String(mainNodeData.id) }; delete mainNode.sideQuests;
            d3Nodes.push(mainNode); nodeById.set(mainNode.id, mainNode);
            if (mainNodeData.sideQuests) {
                mainNodeData.sideQuests.forEach((sqData, index) => {
                    const cards = Array.isArray(sqData.cards) && sqData.cards.length ? sqData.cards : [sqData.content || ''];
                    let previousId = null;
                    const hasMultiple = cards.length > 1;
                    const randLeftRight = (((parseInt(mainNodeData.id, 10) || 0) * 9301 + index * 49297) % 2) === 0 ? -1 : 1;
                    const branchDir = hasMultiple ? 1 : randLeftRight; // multi: always right, single: random left/right
                    cards.forEach((card, cardIdx) => {
                        const cardContent = typeof card === 'object' ? (card.content || '') : card;
                        const cardNext = typeof card === 'object' ? (card.nextLabel || '') : '';
                        const cardPrev = typeof card === 'object' ? (card.prevLabel || '') : '';
                        const sideQuestId = `${mainNodeData.id}-${sqData.type}-${index}-${cardIdx}`;
                        const titleSuffix = cards.length > 1 ? ` (${cardIdx + 1}/${cards.length})` : '';
                        const cardTitle = typeof card === 'object' ? (card.title || '') : (sqData.title || '');
                        const sideQuestNode = { ...sqData, id: sideQuestId, type: 'sidequest', parentId: String(mainNodeData.id), content: cardContent, cardIndex: cardIdx, numCards: cards.length, title: cardTitle, buttonText: sqData.buttonText + titleSuffix, nextLabel: cardNext || sqData.nextLabel || '', backLabel: cardPrev || sqData.backLabel || '', prevId: previousId || null, nextId: null, branchDir };
                        d3Nodes.push(sideQuestNode); nodeById.set(sideQuestNode.id, sideQuestNode);
                        if (previousId) { d3Links.push({ source: previousId, target: sideQuestId }); const prevNode = nodeById.get(previousId); if (prevNode) prevNode.nextId = sideQuestId; }
                        else { d3Links.push({ source: String(mainNodeData.id), target: sideQuestId }); }
                        previousId = sideQuestId;
                    });
                });
            }
            Object.values(mainNodeData.connections).forEach(targetId => { d3Links.push({ source: mainNode.id, target: String(targetId) }); });
        });

        let width = 0, height = 0;
        if (hasD3 && svgContainer) {
          const rect = svgContainer.node().getBoundingClientRect();
          width = rect.width || 400;
          height = rect.height || (window.innerHeight || 800);
        }
        const validLinks = d3Links.filter(l => nodeById.has(String(l.target)) && nodeById.has(String(l.source)));
        // Side-quest motion tuning (live-updated during pan)
        let sqXStrength = 0.055, sqYStrength = 0.085, sqLinkStrength = 0.25;

        
        function updateMainPathPositions() {
            if (!hasD3 || !svgContainer || !svg) return;
            const rect = svgContainer.node().getBoundingClientRect();
            let w = rect.width, h = rect.height;
            // When the sidebar starts collapsed, width can be 0. Use safe fallbacks to avoid crumpling.
            if (!w || w === 0) w = 400; // logical layout width while collapsed
            if (!h || h === 0) h = window.innerHeight || 800;
            width = w; height = h;
            svg.attr('viewBox', `0 0 ${width} ${height}`);
            const mainPath = d3Nodes.filter(n => n.type === 'main' || n.type === 'flip-cards');
            const MAIN_NODE_MIN_STEP = 160; // ensures long, calm gaps between main nodes
            const distributedStep = (height * 0.9) / (mainPath.length > 1 ? mainPath.length - 1 : 1);
            const mainYStep = Math.max(MAIN_NODE_MIN_STEP, distributedStep);
            mainPath.forEach((n, i) => { n.targetFy = height * 0.05 + i * mainYStep; n.targetFx = width / 2; if (typeof n.x === 'undefined' || typeof n.y === 'undefined') { n.x = n.targetFx; n.y = n.targetFy; } });
            updateSideQuestPositions();
        }
        updateMainPathPositions();

        function updateSideQuestPositions() {
            if (!hasD3) return;
            const baseHorizontal = Math.max(140, Math.min(240, Math.round((width || 400) * 0.20)));
            const verticalStep = 92;
            d3Nodes.forEach(n => {
                if (n.type === 'sidequest') {
                    const parent = nodeById.get(String(n.parentId));
                    if (parent && (typeof parent.targetFy !== 'undefined' || typeof parent.fy !== 'undefined')) {
                        const pfx = typeof parent.targetFx === 'number' ? parent.targetFx : (typeof parent.fx === 'number' ? parent.fx : width / 2);
                        const pfy = typeof parent.targetFy === 'number' ? parent.targetFy : (typeof parent.fy === 'number' ? parent.fy : height / 2);
                        const idx = typeof n.cardIndex === 'number' ? n.cardIndex : 0;
                        const dir = n.branchDir || 1; // 1=right, -1=left
                        const t = (idx + 1) / Math.max(2, (n.numCards || 2));
                        const arcPush = Math.sin(t * Math.PI) * 30; // arched curve feel
                        const jitterSeed = ((parseInt(n.parentId, 10) || 0) * 8341 + idx * 2718) % 7;
                        const jitterX = (jitterSeed - 3) * 1.2;
                        const jitterY = ((jitterSeed * 2) % 5 - 2) * 1.2;
                        n.targetFx = pfx + dir * (baseHorizontal + arcPush) + jitterX;
                        n.targetFy = pfy + (idx + 1) * verticalStep + jitterY;
                        if (typeof n.x === 'undefined' || typeof n.y === 'undefined') {
                            n.x = n.targetFx; n.y = n.targetFy;
                        }
                    }
                }
            });
        }

        if (hasD3) {
          simulation = d3.forceSimulation(d3Nodes)
            .velocityDecay(0.36)
            .force('link', d3.forceLink(validLinks)
              .id(d => d.id)
              .distance(d => {
                const sType = (d.source && d.source.type) || (nodeById.get(String(d.source)) || {}).type;
                const tType = (d.target && d.target.type) || (nodeById.get(String(d.target)) || {}).type;
                const involvesSQ = (sType === 'sidequest') || (tType === 'sidequest');
                return involvesSQ ? 140 : 120;
              })
              .strength(d => {
                const sType = (d.source && d.source.type) || (nodeById.get(String(d.source)) || {}).type;
                const tType = (d.target && d.target.type) || (nodeById.get(String(d.target)) || {}).type;
                const involvesSQ = (sType === 'sidequest') || (tType === 'sidequest');
                return involvesSQ ? sqLinkStrength : 0.9;
              })
            )
            .force('charge', d3.forceManyBody().strength(-450))
            .force('collide', d3.forceCollide(20))
            // Softly guide main nodes toward their targets so they have physics
            .force('mainX', d3.forceX(d => (d.type !== 'sidequest' && typeof d.targetFx === 'number') ? d.targetFx : width / 2).strength(d => d.type !== 'sidequest' ? 0.06 : 0))
            .force('mainY', d3.forceY(d => (d.type !== 'sidequest' && typeof d.targetFy === 'number') ? d.targetFy : height / 2).strength(d => d.type !== 'sidequest' ? 0.08 : 0))
            .force('sqX', d3.forceX(d => (d.type === 'sidequest' && typeof d.targetFx === 'number') ? d.targetFx : width / 2).strength(d => d.type === 'sidequest' ? sqXStrength : 0))
            .force('sqY', d3.forceY(d => (d.type === 'sidequest' && typeof d.targetFy === 'number') ? d.targetFy : height / 2).strength(d => d.type === 'sidequest' ? sqYStrength : 0));
          link = g.append('g').attr('class', 'links').selectAll('line').data(validLinks).join('line').attr('class', 'link');
          node = g.append('g').attr('class', 'nodes').selectAll('g').data(d3Nodes).join('g').attr('class', 'node')
            .on('click', (event, d) => updateView(d.id))
            .on('mouseover', function(event, d) { tooltip.style('visibility', 'visible').style('opacity', 1); tooltip.html(`<div class="tooltip-title">${d.title}</div><div class="tooltip-type">${d.type === 'sidequest' ? `▶ ${d.type.charAt(0).toUpperCase() + d.type.slice(1)}` : 'ⓘ Main Step'}</div>`); })
            .on('mousemove', function(event) { const [x, y] = d3.pointer(event, document.body); tooltip.style('left', (x + 20) + 'px').style('top', (y + 20) + 'px'); })
            .on('mouseout', function() { tooltip.style('visibility', 'hidden').style('opacity', 0); });
          node.append('circle').attr('r', 12);
                     zoom = d3.zoom().scaleExtent([0.5, 3])
             .on('start', () => { if (simulation) { sqXStrength = 0.08; sqYStrength = 0.12; sqLinkStrength = 0.32; simulation.alphaTarget(0.2).restart(); } })
             .on('zoom', (event) => { g.attr('transform', event.transform); if (simulation) simulation.alpha(0.06).restart(); })
             .on('end', () => { if (simulation) { sqXStrength = 0.055; sqYStrength = 0.085; sqLinkStrength = 0.25; simulation.alphaTarget(0); } });
           svg.call(zoom);
        }

        function centerNode(nodeId) {
            const targetNode = nodeById.get(nodeId); if (!targetNode || typeof targetNode.x === 'undefined') return;
            const currentTransform = d3.zoomTransform(svg.node());
            const targetX = -targetNode.x * currentTransform.k + width / 2; const targetY = -targetNode.y * currentTransform.k + Math.min(height * 0.45, 260);
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(targetX, targetY).scale(currentTransform.k));
        }
        if (hasD3 && simulation) {
          simulation.on('tick', () => {
            link.attr('x1', d => d.source.x).attr('y1', d => d.source.y).attr('x2', d => d.target.x).attr('y2', d => d.target.y);
            node.attr('transform', d => `translate(${d.x},${d.y})`);
          });
        }

        function updateView(nodeId) {
          activeNodeId = nodeId; visitedNodes.add(nodeId);
          const n = nodeById.get(nodeId);
          if(!n) { console.error(`Node with id "${nodeId}" not found.`); return; }

          // Auto-open/close sidebar for side quests
          const sidebar = document.getElementById('flow-map-container');
          const openBtn = document.getElementById('open-sidebar-btn');
          const closeBtn = document.getElementById('close-sidebar-btn');

          if (n.type === 'sidequest') {
              if (n.numCards > 1 && sidebar && sidebar.classList.contains('collapsed')) {
                  wasSidebarClosedBeforeSideQuest = true;
                  if (openBtn) openBtn.click();
              }
          } else if (n.type === 'main' || n.type === 'flip-cards') {
              if (wasSidebarClosedBeforeSideQuest) {
                  if (sidebar && !sidebar.classList.contains('collapsed')) {
                      if (closeBtn) closeBtn.click();
                  }
                  wasSidebarClosedBeforeSideQuest = false; // Always reset
              }
          }

          // Maintain main path history whenever landing on a main node via any navigation
          if (n.type === 'main' || n.type === 'flip-cards') {
            if (!skipHistoryPush) {
              const last = mainPathHistory[mainPathHistory.length - 1];
              if (last !== n.id) mainPathHistory.push(n.id);
            }
            skipHistoryPush = false;
          }
          
          // Scroll to top of content area when navigating to a new node
          const contentArea = document.getElementById('content-area');
          if (contentArea) {
            contentArea.scrollTop = 0;
          }
          
          const cardTitleEl = document.getElementById('card-title');
          // Apply title alignment if present on node
          if (n['title-align'] && String(n['title-align']).toLowerCase() === 'center') {
            cardTitleEl.style.textAlign = 'center';
          } else {
            cardTitleEl.style.textAlign = '';
          }
          // Fallback extractors in case meta wasn't propagated
          const extractHeader = (source, key) => {
            if (!source) return '';
            const re = new RegExp("(?:^|\\n)\\[" + key + ":\\s*([^\\]]+)\\]", 'i');
            const m = source.match(re);
            return m ? m[1].trim() : '';
          };
          const effectiveTitle = (n.title && n.title.trim().length) ? n.title : extractHeader(n.content, 'title');
          const effectiveNext = (n.nextLabel && n.nextLabel.trim().length) ? n.nextLabel : extractHeader(n.content, 'next');

          if (n.type === 'sidequest') {
            if (effectiveTitle && effectiveTitle.trim() !== '') {
              const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
              cardTitleEl.innerHTML = processBold(effectiveTitle);
              cardTitleEl.style.display = '';
            } else {
              cardTitleEl.textContent = '';
              cardTitleEl.style.display = 'none';
            }
          } else if (n.title && n.title.trim() !== '') {
            const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            cardTitleEl.innerHTML = processBold(n.title);
            cardTitleEl.style.display = '';
          } else {
            cardTitleEl.textContent = '';
            cardTitleEl.style.display = 'none';
          }

          const cardContentEl = document.getElementById('card-content');
          renderContent(cardContentEl, n.content, n.type);

          const btnsContainer = document.getElementById('card-buttons');
          btnsContainer.innerHTML = `
              <div id="card-buttons-left"></div>
              <div id="card-buttons-right"></div>
          `;
          const leftButtons = btnsContainer.querySelector('#card-buttons-left');
          const rightButtons = btnsContainer.querySelector('#card-buttons-right');

          // If the card content stored a top-level resource URL (content was a bare URL),
          // render an "Open Resource" button in the bottom-left, regardless of node type.
          const cardContentElRef = document.getElementById('card-content');
          const resourceUrl = cardContentElRef.getAttribute('data-resource-url');
          const resourceTitle = cardContentElRef.getAttribute('data-resource-title') || 'Open Resource';
          const inlineButtonsJson = cardContentElRef.getAttribute('data-buttons');
          if (inlineButtonsJson) {
              try {
                  const btns = JSON.parse(inlineButtonsJson);
                  btns.forEach(b => {
                      const ib = document.createElement('button');
                      ib.className = 'btn-sidequest';
                      ib.innerHTML = `<span>${b.buttonText || 'Open'}</span>`;
                      ib.onclick = (ev) => { ev && ev.preventDefault && ev.preventDefault(); openInEmbed(b.url, b.buttonText || 'Open'); };
                      leftButtons.appendChild(ib);
                  });
              } catch (_) {}
              cardContentElRef.removeAttribute('data-buttons');
          }
          if (resourceUrl) {
              const btn = document.createElement('button');
              btn.className = 'btn-sidequest';
              btn.innerHTML = `<span>${resourceTitle}</span>`;
              btn.onclick = (ev) => handleResourceClick(ev, resourceUrl, resourceTitle);
              leftButtons.appendChild(btn);
              // Clear after consuming so subsequent nodes don't inherit
              cardContentElRef.removeAttribute('data-resource-url');
              cardContentElRef.removeAttribute('data-resource-title');
          }
 
          if (n.type === 'main' || n.type === 'flip-cards') {
              if (mainPathHistory.length > 1) {
                const prevBtn = document.createElement('button');
                prevBtn.className = 'btn-prev';
                prevBtn.innerHTML = `<svg width="12" height="18" viewBox="0 0 12 18" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" style="transform: rotate(180deg);"><path d="M2 2L9 9L2 16" stroke="#8A8A8A" stroke-width="3" stroke-linecap="round"/></svg><span>Previous</span>`;
                prevBtn.onclick = () => {
                  // Step back one main node and navigate without re-adding to history
                  if (mainPathHistory.length > 1) {
                    mainPathHistory.pop();
                    const prevNodeId = mainPathHistory[mainPathHistory.length - 1];
                    skipHistoryPush = true;
                    updateView(prevNodeId);
                  }
                };
                rightButtons.appendChild(prevBtn);
              }
              const mainNodeData = courseData.find(d => String(d.id) === n.id);
              if (mainNodeData && mainNodeData.sideQuests) {
                  mainNodeData.sideQuests.forEach((sq, index) => {
                      const btn = document.createElement('button');
                      btn.className = 'btn-sidequest';
                      btn.innerHTML = `<span>${sq.buttonText}</span>`;
                      btn.onclick = () => updateView(`${n.id}-${sq.type}-${index}-0`);
                      leftButtons.appendChild(btn);
                  });
              }
              if (mainNodeData && mainNodeData.links) {
                  const mainSequence = courseData.filter(d => d && (d.type === 'main' || d.type === 'flip-cards'));
                  const lastMainId = mainSequence.length ? String(mainSequence[mainSequence.length - 1].id) : null;
                  const isLastMain = lastMainId === n.id;
                  mainNodeData.links.forEach(link => {
                      const btn = document.createElement('button');
                      if (isLastMain) {
                          btn.className = 'btn-primary';
                          btn.innerHTML = `<span>${link.buttonText}</span><svg width="12" height="18" viewBox="0 0 12 18" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><path d="M2 2L9 9L2 16" stroke="white" stroke-width="3" stroke-linecap="round"/></svg>`;
                      } else {
                          btn.className = 'btn-sidequest';
                          btn.innerHTML = `<span>${link.buttonText}</span>`;
                      }
                      btn.onclick = (ev) => {
                          if ((link.target || 'newtab') === 'embed') {
                              // Force embed regardless of modifier keys
                              openInEmbed(link.url, link.buttonText);
                              return;
                          }
                          // Default: new tab
                          window.open(link.url, '_blank');
                      };
                      (isLastMain ? rightButtons : leftButtons).appendChild(btn);
                  });
              }
              for (const [label, targetId] of Object.entries(n.connections)) {
                  const btn = document.createElement('button');
                  btn.className = 'btn-primary';
                  btn.innerHTML = `<span>${label}</span><svg width="12" height="18" viewBox="0 0 12 18" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><path d="M2 2L9 9L2 16" stroke="white" stroke-width="3" stroke-linecap="round"/></svg>`;
                  btn.onclick = () => updateView(String(targetId));
                  rightButtons.appendChild(btn);
              }
          } else if (n.type === 'sidequest') {
              if (n.prevId) {
                const prevBtn = document.createElement('button');
                prevBtn.textContent = n.backLabel || '◀ Previous';
                prevBtn.onclick = () => updateView(n.prevId);
                leftButtons.appendChild(prevBtn);
              }
              if (n.nextId) {
                const nextBtn = document.createElement('button');
                nextBtn.textContent = (effectiveNext && effectiveNext.trim().length) ? effectiveNext : ((n.nextLabel && n.nextLabel.trim().length) ? n.nextLabel : 'Next ▶');
                nextBtn.onclick = () => updateView(n.nextId);
                leftButtons.appendChild(nextBtn);
              }
              const btn = document.createElement('button');
              btn.textContent = n.backToMainLabel || n.backLabel || 'Return to main path';
              btn.onclick = () => updateView(String(n.parentId));
              rightButtons.appendChild(btn);
          }
          
          if (hasD3) {
            node.classed('active', d => d.id === activeNodeId)
              .classed('visited-main', d => visitedNodes.has(d.id) && (d.type === 'main' || d.type === 'flip-cards') && d.id !== activeNodeId)
              .classed('visited-sidequest', d => visitedNodes.has(d.id) && d.type === 'sidequest' && d.id !== activeNodeId)
              .classed('unvisited', d => !visitedNodes.has(d.id));
            link.classed('visited-main', d => visitedNodes.has(d.source.id) && visitedNodes.has(d.target.id))
              .classed('visited-sidequest', d => visitedNodes.has(d.source.id) && visitedNodes.has(d.target.id) && (nodeById.get(d.source.id)?.type === 'sidequest' || nodeById.get(d.target.id)?.type === 'sidequest'));
            centerNode(nodeId);
          }
        }

        if (!hasD3) { document.getElementById('flow-map-container').style.display = 'none'; }
        const resizer = document.getElementById('resizer'); const sidebar = document.getElementById('flow-map-container'); const closeBtn = document.getElementById('close-sidebar-btn'); const openBtn = document.getElementById('open-sidebar-btn');
        let isResizing = false;
        resizer.addEventListener('mousedown', (e) => { isResizing = true; document.body.style.cursor = 'col-resize'; sidebar.style.transition = 'none'; });
        window.addEventListener('mousemove', (e) => { if (!isResizing) return; const newWidth = e.clientX; if (newWidth > 200 && newWidth < document.body.clientWidth - 400) { sidebar.style.width = newWidth + 'px'; updateMainPathPositions(); simulation.alpha(0.1).restart(); } });
        window.addEventListener('mouseup', (e) => { if (isResizing) { isResizing = false; document.body.style.cursor = 'default'; sidebar.style.transition = ''; updateMainPathPositions(); simulation.alpha(0.3).restart(); } });
        closeBtn.addEventListener('click', () => { sidebar.classList.add('collapsed'); openBtn.style.display = 'block'; });
        openBtn.addEventListener('click', () => { sidebar.classList.remove('collapsed'); openBtn.style.display = 'none'; const tip = document.getElementById('open-sidebar-tip'); if (tip) tip.classList.remove('visible'); setTimeout(() => { updateMainPathPositions(); simulation.alpha(0.3).restart(); }, 500); });

        // Auto-start with sidebar closed and show helper tip briefly on first visit
        (function initSidebarState() {
          const tip = document.getElementById('open-sidebar-tip');
          // If sidebar starts collapsed (which it now does by default), ensure the open button is visible.
          if (sidebar.classList.contains('collapsed')) {
            openBtn.style.display = 'block';
          }
          const hasSeenTip = sessionStorage.getItem('openSidebarTipSeen') === '1';
          const showTip = () => { if (tip) tip.classList.add('visible'); };
          const hideTip = () => { if (tip) tip.classList.remove('visible'); };
          if (!hasSeenTip) {
            // Defer showing until after layout/paint for reliability
            requestAnimationFrame(() => {
              setTimeout(() => {
                showTip();
                setTimeout(() => { hideTip(); sessionStorage.setItem('openSidebarTipSeen', '1'); }, 2600);
              }, 50);
            });
          }
          // Show tip on hover/focus of the open button
          if (openBtn) {
            openBtn.addEventListener('mouseenter', showTip);
            openBtn.addEventListener('mouseleave', hideTip);
            openBtn.addEventListener('focus', showTip);
            openBtn.addEventListener('blur', hideTip);
          }
        })();

        updateView(activeNodeId);
    })();
  </script>
</body>
</html>