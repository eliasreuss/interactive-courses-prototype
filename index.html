<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Learning Flow Visualization</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --color-bg: #FAFAFA;
      --color-card-bg: #FFFFFF;
      --color-primary-text: #304642;
      --color-accent: #FF5A00;
      --color-visited-main: #304642;
      --color-visited-sidequest: #B4BDA3;
      --color-unvisited: #D5D5D5;
      --font-family: 'Poppins', sans-serif;
    }
    html, body {
      height: 100%; margin: 0; padding: 0; background: var(--color-bg); font-family: var(--font-family); color: var(--color-primary-text); overflow: hidden;
    }
    .container { display: flex; height: 100vh; width: 100vw; box-sizing: border-box; }
    #flow-map-container {
      width: 400px; min-width: 0; background: var(--color-bg); display: flex; flex-direction: column; position: relative; cursor: grab; flex-shrink: 0;
    }
    #flow-map-container.collapsed { width: 0 !important; padding: 0; border: none; }
    #flow-map-container:active { cursor: grabbing; }
    #flow-map-svg {
      width: 100%; height: 100%; display: block;
      background-image: radial-gradient(circle, #E0E0E0 1px, transparent 1px);
      background-size: 20px 20px;
    }
    #resizer { width: 8px; height: 100%; position: absolute; right: 0; top: 0; cursor: col-resize; background: transparent; z-index: 20; }
    #close-sidebar-btn {
      position: absolute; top: 10px; right: 10px; width: 24px; height: 24px; background: rgba(0,0,0,0.1); border: none; border-radius: 50%;
      color: #333; cursor: pointer; font-size: 16px; line-height: 24px; text-align: center; z-index: 21; opacity: 0.5; transition: opacity 0.2s, background 0.2s;
    }
    #close-sidebar-btn:hover { opacity: 1; background: rgba(0,0,0,0.2); }
    #open-sidebar-btn {
      display: none; position: absolute; left: 10px; top: 50%; transform: translateY(-50%); padding: 8px 12px; background: var(--color-card-bg);
      border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; z-index: 30;
    }
    #tooltip {
      position: absolute; visibility: hidden; background-color: #333; color: #fff; padding: 8px 12px; border-radius: 6px;
      font-size: 0.9rem; pointer-events: none; transition: opacity 0.2s; opacity: 0; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    #tooltip .tooltip-title { font-weight: 600; }
    #tooltip .tooltip-type { font-size: 0.8rem; opacity: 0.8; margin-top: 4px; }
    
    #content-area {
        flex: 1 1 auto; display: flex; justify-content: center; align-items: center;
        padding: 72px; box-sizing: border-box; overflow: auto;
    }
    #content-card {
      width: 100%; height: 100%; background: var(--color-card-bg); border-radius: 18px; box-shadow: 0 4px 32px 0 rgba(60,60,60,0.07);
      padding: 40px 36px 32px 36px; display: flex; flex-direction: column; overflow-y: auto; box-sizing: border-box;
    }
    #card-text-content { flex-grow: 1; }
    #card-title { font-size: 2rem; font-weight: 600; margin-bottom: 12px; color: var(--color-primary-text); }
    #card-content { font-size: 1.1rem; color: var(--color-primary-text); white-space: pre-wrap; line-height: 1.7; overflow-wrap: break-word; }
    #card-content p { margin: 0 0 1em 0; }
    #card-content strong { font-weight: 600; }
    #card-content ul {
      list-style: none; /* Remove default styling */
      padding-left: 1em;
      margin: 1em 0;
    }
    #card-content li {
      padding-left: 1.2em;
      position: relative;
      margin-bottom: 0.5em;
    }
    #card-content li::before {
      content: '•'; /* Use a solid bullet character */
      color: var(--color-primary-text); /* Use the main text color */
      font-weight: bold;
      font-size: 1.1em;
      position: absolute;
      left: 0;
      top: -0.1em; /* Fine-tune vertical alignment */
    }
    .content-images-container {
      display: flex; gap: 20px; justify-content: center; margin: 30px 0; flex-wrap: wrap; align-items: center;
    }
    .content-images-container img {
      max-width: 100%; height: auto; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); background-color: #f0f0f0;
    }
    .content-images-container .img-container {
        display: flex;
        justify-content: center;
    }
    .content-images-container .img-container.size-large {
        flex-basis: 100%;
    }
    .content-images-container .size-small { max-width: 25%; flex-basis: 25%; }
    .content-images-container .size-medium { max-width: 50%; flex-basis: 50%; }
    .content-images-container .size-large { max-width: 100%; flex-basis: 100%; }
    
    #card-buttons {
      display: flex; gap: 12px; flex-wrap: wrap; justify-content: flex-end; margin-top: 24px;
    }
    #card-buttons button {
      background: var(--color-accent); color: #fff; border: none; border-radius: 50px; padding: 10px 24px;
      font-size: 14px; font-family: var(--font-family); font-weight: 600; cursor: pointer; transition: background 0.2s, box-shadow 0.2s;
      box-shadow: 0 2px 8px 0 rgba(255,90,0,0.15);
    }
    #card-buttons button:hover { background: #e04e00; }
    .resource-link-btn {
      display: inline-flex; align-items: center; justify-content: center; gap: 10px; margin-top: 20px; padding: 12px 28px;
      background-color: var(--color-accent); color: white; text-decoration: none; border-radius: 50px; font-weight: 600;
      box-shadow: 0 2px 8px 0 rgba(255,90,0,0.2); transition: all 0.2s;
    }
    .resource-link-btn:hover { background-color: #e04e00; transform: translateY(-2px); box-shadow: 0 4px 12px 0 rgba(255,90,0,0.3); }

    .link { stroke: #999; stroke-opacity: 0.6; }
    .link.visited-main, .link.visited-sidequest { stroke: var(--color-visited-main); stroke-width: 2.5px; }
    .link.visited-sidequest { stroke-dasharray: 4 4; }
    .node circle {
        transition: all 0.2s; fill: var(--color-unvisited); cursor: pointer;
    }
    .node:hover circle { transform: scale(1.1); }
    .node.unvisited circle { fill: var(--color-unvisited); }
    .node.visited-main circle { fill: var(--color-visited-main); }
    .node.visited-sidequest circle { fill: var(--color-visited-sidequest); }
    .node.active circle { fill: var(--color-accent); filter: drop-shadow(0 0 10px var(--color-accent)); r: 15 !important; }
    
    @media (max-width: 900px) { /* Media query for responsive is unchanged */ }
  </style>
</head>
<body>
  <div class="container">
    <div id="flow-map-container">
      <svg id="flow-map-svg"></svg>
      <div id="tooltip"></div>
      <div id="resizer"></div>
      <button id="close-sidebar-btn" title="Close Flow Map">×</button>
    </div>
    <div id="content-area">
        <button id="open-sidebar-btn" title="Open Flow Map">➔</button>
        <div id="content-card">
            <div id="card-text-content">
                <h2 id="card-title">Loading...</h2>
                <div id="card-content"></div>
            </div>
            <div id="card-buttons"></div>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
  <script>
    function renderContent(element, text) {
        const content = text || '';
        // --- Handle special content types first (YouTube, links) ---
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
        const youtubeMatch = content.match(youtubeRegex);
        if (youtubeMatch) {
            const videoId = youtubeMatch[1];
            element.innerHTML = `<div style="position: relative; width: 100%; padding-top: 56.25%; background: #eee; border-radius: 8px; overflow: hidden;"><iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" src="https://www.youtube.com/embed/${videoId}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`;
            return;
        }
        if (content.startsWith('http://') || content.startsWith('https://')) {
            element.innerHTML = `<a href="${content}" target="_blank" rel="noopener noreferrer" class="resource-link-btn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M13.194 10.806a1.5 1.5 0 1 0-2.122-2.122 1.5 1.5 0 0 0 2.122 2.122Zm-.708 6.364a1.5 1.5 0 1 0-2.122-2.122 1.5 1.5 0 0 0 2.122 2.122ZM12 3.5A8.5 8.5 0 1 1 3.5 12 8.5 8.5 0 0 1 12 3.5ZM10.5 12a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0Zm6 0a1.5 1.5 0 1 0-3 0 1.5 1.5 0 0 0 3 0Z"></path></svg><span>Open Resource</span></a>`;
            return;
        }

        // --- Handle standard text, image, and list content ---
        let html = '';
        const lines = content.split('\n');
        let inList = false;

        for (const line of lines) {
            const trimmedLine = line.trim();
            const isListItem = trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ') || trimmedLine.startsWith('-');

            // Process bold markdown within any line
            const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

            if (isListItem) {
                if (!inList) {
                    html += '<ul>';
                    inList = true;
                }
                const listItemContent = processBold(trimmedLine.startsWith('- ') ? trimmedLine.substring(2) : trimmedLine.substring(1));
                html += `<li>${listItemContent}</li>`;
            } else {
                if (inList) {
                    html += '</ul>';
                    inList = false;
                }

                const imageRegex = /!\[(.*?)(?:\|size:(small|medium|large))?\]\((.*?)\)/g;
                const images = [...line.matchAll(imageRegex)];

                if (images.length > 0) {
                    let imageHtml = '<div class="content-images-container">';
                    images.forEach(imgMatch => {
                        const altText = imgMatch[1];
                        const sizeClass = imgMatch[2] ? `size-${imgMatch[2]}` : 'size-large';
                        const imgSrc = `images/${imgMatch[3]}`;
                        imageHtml += `<div class="img-container ${sizeClass}"><img src="${imgSrc}" alt="${altText}"></div>`;
                    });
                    imageHtml += '</div>';
                    html += imageHtml;
                } else if (trimmedLine === '' && html.length > 0) {
                    html += '<p> </p>';
                } else if (trimmedLine !== '') {
                    html += `<p>${processBold(line)}</p>`;
                }
            }
        }

        if (inList) {
            html += '</ul>'; // Close any list that's still open
        }

        element.innerHTML = html;
    }

    // --- START: NEW, MORE ROBUST PARSER ---
    function parseFlowScript(text) {
        const sideQuestContentMap = new Map();
        const mainNodes = [];
        let currentBlock = null;

        // First pass to extract side quest content blocks, which are self-contained
        const sqRegex = /\[side-quest-content:([^\]]+)\]\s*\n---\n([\s\S]*?)\n---/g;
        let remainingText = text.replace(sqRegex, (match, type, content) => {
            sideQuestContentMap.set(type.trim(), content.trim());
            return ''; // Remove the block from the text
        });

        // Second, line-by-line pass for main nodes
        const lines = remainingText.split('\n');
        let isContent = false;
        
        for (const line of lines) {
            if (line.trim().startsWith('id:')) {
                // Finish previous node before starting a new one
                if (currentBlock) mainNodes.push(currentBlock);
                currentBlock = { connections: {}, sideQuests: [] };
                isContent = false;
            }

            if (!currentBlock) continue;

            if (line.trim() === '---') {
                isContent = !isContent;
                continue;
            }

            if (isContent) {
                currentBlock.content = (currentBlock.content || '') + line + '\n';
            } else {
                if (line.startsWith('>')) {
                    const mainMatch = line.match(/>\s*(.+?)\s*->\s*(\d+)/);
                    const sqMatch = line.match(/>\s*(.+?)\s*->\s*\[(.+?):(.+?)\]/);
                    if (mainMatch) {
                        currentBlock.connections[mainMatch[1].trim()] = parseInt(mainMatch[2]);
                    } else if (sqMatch) {
                        const [, buttonText, type, title] = sqMatch;
                        currentBlock.sideQuests.push({ type, title, buttonText, content: sideQuestContentMap.get(type) || '' });
                    }
                } else {
                    const [key, ...valueParts] = line.split(':');
                    if (valueParts.length > 0) {
                        const value = valueParts.join(':').trim();
                        currentBlock[key.trim()] = key.trim() === 'id' ? parseInt(value) : value;
                    }
                }
            }
        }
        // Add the last node to the array
        if (currentBlock) mainNodes.push(currentBlock);

        // Clean up the content for each node
        mainNodes.forEach(node => {
            if (node.content) node.content = node.content.trim();
        });
        
        return mainNodes;
    }
    // --- END: NEW, MORE ROBUST PARSER ---
    
    // The main execution block (no changes needed here)
    (async function() {
        let courseData;
        try {
            const urlParams = new URLSearchParams(window.location.search);
            const courseFile = urlParams.get('course') || 'Double-ABC-Analysis.txt';
            const response = await fetch('courses/' + courseFile);
            if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
            const text = await response.text();
            courseData = parseFlowScript(text);
            if (!courseData || courseData.length === 0) { throw new Error("Parsing resulted in no valid course data."); }
        } catch (error) {
            console.error('Error loading or parsing course file:', error);
            document.getElementById('card-title').textContent = 'Error';
            document.getElementById('card-content').innerHTML = 'Could not load the course. Please check that <strong>course.txt</strong> exists and is valid. Remember to use a local server.';
            return;
        }

        let activeNodeId = '1'; let visitedNodes = new Set(['1']);
        const svgContainer = d3.select('#flow-map-container'); const svg = d3.select('#flow-map-svg'); const g = svg.append('g'); const tooltip = d3.select('#tooltip');
        const d3Nodes = [], d3Links = [], nodeById = new Map();

        courseData.forEach(mainNodeData => {
            if (!mainNodeData.id) return; // Skip invalid nodes
            const mainNode = { ...mainNodeData, id: String(mainNodeData.id) }; delete mainNode.sideQuests;
            d3Nodes.push(mainNode); nodeById.set(mainNode.id, mainNode);
            if (mainNodeData.sideQuests) {
                mainNodeData.sideQuests.forEach(sqData => {
                    const sideQuestId = `${mainNodeData.id}-${sqData.type}`; const sideQuestNode = { ...sqData, id: sideQuestId, type: 'sidequest', parentId: mainNode.id };
                    d3Nodes.push(sideQuestNode); nodeById.set(sideQuestNode.id, sideQuestNode); d3Links.push({ source: mainNode.id, target: sideQuestId });
                });
            }
            Object.values(mainNodeData.connections).forEach(targetId => { d3Links.push({ source: mainNode.id, target: String(targetId) }); });
        });

        let width = svgContainer.node().getBoundingClientRect().width; let height = svgContainer.node().getBoundingClientRect().height;
        
        function updateMainPathPositions() {
            width = svgContainer.node().getBoundingClientRect().width; height = svgContainer.node().getBoundingClientRect().height; if (width === 0 || height === 0) return;
            svg.attr('viewBox', `0 0 ${width} ${height}`);
            const mainPath = d3Nodes.filter(n => n.type === 'main'); const mainYStep = (height * 0.9) / (mainPath.length > 1 ? mainPath.length - 1 : 1);
            mainPath.forEach((n, i) => { n.fy = height * 0.05 + i * mainYStep; n.fx = width / 2; });
        }
        updateMainPathPositions();

        const simulation = d3.forceSimulation(d3Nodes).force('link', d3.forceLink(d3Links).id(d => d.id).distance(80).strength(0.8)).force('charge', d3.forceManyBody().strength(-500)).force('collide', d3.forceCollide(20));
        const link = g.append('g').attr('class', 'links').selectAll('line').data(d3Links).join('line').attr('class', 'link');
        const node = g.append('g').attr('class', 'nodes').selectAll('g').data(d3Nodes).join('g').attr('class', 'node')
          .on('click', (event, d) => updateView(d.id))
          .on('mouseover', function(event, d) { tooltip.style('visibility', 'visible').style('opacity', 1); tooltip.html(`<div class="tooltip-title">${d.title}</div><div class="tooltip-type">${d.type === 'sidequest' ? `▶ ${d.type.charAt(0).toUpperCase() + d.type.slice(1)}` : 'ⓘ Main Step'}</div>`); })
          .on('mousemove', function(event) { const [x, y] = d3.pointer(event, document.body); tooltip.style('left', (x + 20) + 'px').style('top', (y + 20) + 'px'); })
          .on('mouseout', function() { tooltip.style('visibility', 'hidden').style('opacity', 0); });
        node.append('circle').attr('r', 12);
        const zoom = d3.zoom().scaleExtent([0.5, 3]).on('zoom', (event) => g.attr('transform', event.transform)); svg.call(zoom);

        function centerNode(nodeId) {
            const targetNode = nodeById.get(nodeId); if (!targetNode || typeof targetNode.x === 'undefined') return;
            const currentTransform = d3.zoomTransform(svg.node());
            const targetX = -targetNode.x * currentTransform.k + width / 2; const targetY = -targetNode.y * currentTransform.k + height / 2;
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(targetX, targetY).scale(currentTransform.k));
        }
        simulation.on('tick', () => {
          link.attr('x1', d => d.source.x).attr('y1', d => d.source.y).attr('x2', d => d.target.x).attr('y2', d => d.target.y);
          node.attr('transform', d => `translate(${d.x},${d.y})`);
        });

        function updateView(nodeId) {
          activeNodeId = nodeId; visitedNodes.add(nodeId);
          const n = nodeById.get(nodeId);
          if(!n) { console.error(`Node with id "${nodeId}" not found.`); return; }
          
          document.getElementById('card-title').textContent = n.title;
          const cardContentEl = document.getElementById('card-content');
          renderContent(cardContentEl, n.content);

          const btns = document.getElementById('card-buttons'); btns.innerHTML = '';
          if (n.type === 'main') {
              const mainNodeData = courseData.find(d => String(d.id) === n.id);
              if (mainNodeData && mainNodeData.sideQuests) {
                  mainNodeData.sideQuests.forEach(sq => { const btn = document.createElement('button'); btn.textContent = sq.buttonText; btn.onclick = () => updateView(`${n.id}-${sq.type}`); btns.appendChild(btn); });
              }
              for (const [label, targetId] of Object.entries(n.connections)) { const btn = document.createElement('button'); btn.textContent = label; btn.onclick = () => updateView(String(targetId)); btns.appendChild(btn); }
          } else if (n.type === 'sidequest') {
              const btn = document.createElement('button'); btn.textContent = 'Return to main path'; btn.onclick = () => updateView(String(n.parentId)); btns.appendChild(btn);
          }
          
          node.classed('active', d => d.id === activeNodeId)
            .classed('visited-main', d => visitedNodes.has(d.id) && d.type === 'main' && d.id !== activeNodeId)
            .classed('visited-sidequest', d => visitedNodes.has(d.id) && d.type === 'sidequest' && d.id !== activeNodeId)
            .classed('unvisited', d => !visitedNodes.has(d.id));
          link.classed('visited-main', d => visitedNodes.has(d.source.id) && visitedNodes.has(d.target.id))
            .classed('visited-sidequest', d => visitedNodes.has(d.source.id) && visitedNodes.has(d.target.id) && (nodeById.get(d.source.id)?.type === 'sidequest' || nodeById.get(d.target.id)?.type === 'sidequest'));
          centerNode(nodeId);
        }

        const resizer = document.getElementById('resizer'); const sidebar = document.getElementById('flow-map-container'); const closeBtn = document.getElementById('close-sidebar-btn'); const openBtn = document.getElementById('open-sidebar-btn');
        let isResizing = false;
        resizer.addEventListener('mousedown', (e) => { isResizing = true; document.body.style.cursor = 'col-resize'; sidebar.style.transition = 'none'; });
        window.addEventListener('mousemove', (e) => { if (!isResizing) return; const newWidth = e.clientX; if (newWidth > 200 && newWidth < document.body.clientWidth - 400) sidebar.style.width = newWidth + 'px'; });
        window.addEventListener('mouseup', (e) => { if (isResizing) { isResizing = false; document.body.style.cursor = 'default'; sidebar.style.transition = ''; updateMainPathPositions(); simulation.alpha(0.3).restart(); } });
        closeBtn.addEventListener('click', () => { sidebar.classList.add('collapsed'); openBtn.style.display = 'block'; });
        openBtn.addEventListener('click', () => { sidebar.classList.remove('collapsed'); openBtn.style.display = 'none'; setTimeout(() => { updateMainPathPositions(); simulation.alpha(0.3).restart(); }, 300); });

        updateView(activeNodeId);
    })();
  </script>
</body>
</html>