<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Learning Flow Visualization</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --color-bg: #FAFAFA;
      --color-card-bg: #FFFFFF;
      --color-primary-text: #304642;
      --color-accent: #FF5A00;
      --color-visited-main: #304642;
      --color-visited-sidequest: #B4BDA3;
      --color-unvisited: #D5D5D5;
      --font-family: 'Poppins', sans-serif;
    }
    html, body {
      height: 100%; margin: 0; padding: 0; background: var(--color-bg); font-family: var(--font-family); color: var(--color-primary-text); overflow: hidden;
    }
    .container { display: flex; height: 100vh; width: 100vw; box-sizing: border-box; }
    #flow-map-container {
      width: 400px; min-width: 0; background: var(--color-bg); display: flex; flex-direction: column; position: relative; cursor: grab; flex-shrink: 0;
    }
    #flow-map-container.collapsed { width: 0 !important; padding: 0; border: none; }
    #flow-map-container:active { cursor: grabbing; }
    #flow-map-svg {
      width: 100%; height: 100%; display: block;
      background-image: radial-gradient(circle, #E0E0E0 1px, transparent 1px);
      background-size: 20px 20px;
    }
    #resizer { width: 8px; height: 100%; position: absolute; right: 0; top: 0; cursor: col-resize; background: transparent; z-index: 20; }
    #close-sidebar-btn {
      position: absolute; top: 10px; right: 10px; width: 24px; height: 24px; background: rgba(0,0,0,0.1); border: none; border-radius: 50%;
      color: #333; cursor: pointer; font-size: 16px; line-height: 24px; text-align: center; z-index: 21; opacity: 0.5; transition: opacity 0.2s, background 0.2s;
    }
    #close-sidebar-btn:hover { opacity: 1; background: rgba(0,0,0,0.2); }
    #open-sidebar-btn {
      display: none; position: absolute; left: 10px; top: 50%; transform: translateY(-50%); padding: 8px 12px; background: var(--color-card-bg);
      border: 1px solid #eee; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; z-index: 30;
    }
    #tooltip {
      position: absolute; visibility: hidden; background-color: #333; color: #fff; padding: 8px 12px; border-radius: 6px;
      font-size: 0.9rem; pointer-events: none; transition: opacity 0.2s; opacity: 0; z-index: 10; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    #tooltip .tooltip-title { font-weight: 600; }
    #tooltip .tooltip-type { font-size: 0.8rem; opacity: 0.8; margin-top: 4px; }
    
    #content-area {
        flex: 1 1 auto; display: flex; align-items: stretch; justify-content: flex-start;
        gap: 16px; padding: 72px; box-sizing: border-box; overflow: hidden;
    }
    #content-card {
      width: 100%; height: 100%; background: var(--color-card-bg); border-radius: 18px; box-shadow: 0 4px 32px 0 rgba(60,60,60,0.07);
      padding: 40px 36px 32px 36px; display: flex; flex-direction: column; overflow-y: auto; box-sizing: border-box;
    }
    #card-text-content { flex-grow: 1; }
    #card-title { font-size: 2rem; font-weight: normal; margin-bottom: 24px; color: var(--color-primary-text); }
    #card-content { font-size: 1.1rem; color: var(--color-primary-text); white-space: pre-wrap; line-height: 1.5; overflow-wrap: break-word; }
    #card-content p { margin: 0 0 0.15em 0; }
    #card-content strong { font-weight: 600; }
    #card-content ul {
      list-style: none; /* Remove default styling */
      padding-left: 1em;
      margin: 1em 0;
    }
    /* Quote component */
    .quote-block { display: grid; grid-template-columns: 32px 1fr; gap: 12px; align-items: start; margin: 24px 0; }
    .quote-mark { color: var(--color-accent); font-weight: 700; font-size: 28px; line-height: 1; }
    .quote-text { font-style: italic; opacity: 0.9; }
    .quote-author { color: #8a8f87; font-size: 0.95rem; margin-top: 6px; }
    #card-content li {
      padding-left: 1.2em;
      position: relative;
      margin-bottom: 0.5em;
    }
    #card-content li::before {
      content: '•'; /* Use a solid bullet character */
      color: var(--color-primary-text); /* Use the main text color */
      font-weight: bold;
      font-size: 1.1em;
      position: absolute;
      left: 0;
      top: -0.1em; /* Fine-tune vertical alignment */
    }
    .content-images-container {
      display: flex; gap: 20px; justify-content: center; margin: 30px 0; flex-wrap: wrap; align-items: center;
    }
    .content-images-container img {
      max-width: 100%; height: auto; display: block;
    }
    .content-images-container .img-container {
        display: flex;
        justify-content: center;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 10px 25px rgba(0,0,0,0.08), 0 3px 8px rgba(0,0,0,0.08);
        background: #fff;
        flex: 1 1 auto;
    }
    /* Borderless media container */
    .content-images-container .img-container.no-frame,
    .content-with-stacked-images .stacked-images .img-container.no-frame {
        background: transparent;
        box-shadow: none;
        border-radius: 0;
    }
    .content-images-container .img-container.size-large,
    .content-images-container .size-large { max-width: 100%; flex-basis: 100%; }
    .content-images-container .size-x-small { max-width: 15%; flex-basis: 15%; }
    .content-images-container .size-small { max-width: 25%; flex-basis: 25%; }
    .content-images-container .size-medium { max-width: 50%; flex-basis: 50%; }
    /* Exact widths that account for the 20px gap between items */
    .content-images-container .size-third { flex: 0 0 calc((100% - 40px) / 3); max-width: calc((100% - 40px) / 3); }
    .content-images-container .size-fourth { flex: 0 0 calc((100% - 60px) / 4); max-width: calc((100% - 60px) / 4); }
    .content-images-container .img-container.size-large {
        flex-basis: 100%;
    }
    .content-images-container .size-x-small { max-width: 15%; flex-basis: 15%; }
    .content-images-container .size-small { max-width: 25%; flex-basis: 25%; }
    .content-images-container .size-medium { max-width: 50%; flex-basis: 50%; }
    .content-images-container .size-large { max-width: 100%; flex-basis: 100%; }

    /* Make videos fill their container, which handles sizing and shadows */
    .img-container video {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
        display: block;
    }

    /* Alignment for the container of a line of images */
    .content-images-container.align-left { justify-content: flex-start; }
    .content-images-container.align-center { justify-content: center; }
    .content-images-container.align-right { justify-content: flex-end; }
    
    /* Special layout for stacked images on the right */
    .content-with-stacked-images {
      display: flex; gap: 30px; align-items: center;
    }
    .content-with-stacked-images .text-content {
      flex: 1; /* Take up remaining space */
    }
    .content-with-stacked-images .stacked-images {
      display: flex; flex-direction: column; gap: 15px; flex-shrink: 0; max-width: clamp(320px, 45%, 800px);
      margin-top: 0; /* Align with top of text content */
    }
    .content-with-stacked-images .stacked-images img { display: block; }
    .content-with-stacked-images .stacked-images .img-container {
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 25px rgba(0,0,0,0.08), 0 3px 8px rgba(0,0,0,0.08);
      background: #fff;
    }
    /* Width sizing for stacked-right media */
    .content-with-stacked-images .stacked-images .size-x-small { max-width: 15%; flex-basis: 15%; }
    .content-with-stacked-images .stacked-images .size-small { max-width: 25%; flex-basis: 25%; }
    .content-with-stacked-images .stacked-images .size-medium { max-width: 50%; flex-basis: 50%; }
    .content-with-stacked-images .stacked-images .size-large { max-width: 100%; flex-basis: 100%; }
    .content-images-container.align-stack-right {
      margin: 0; /* Remove default margins for stacked layout */
    }

    /* --- Flip Card Styles (Overhauled for Simplicity & Robustness) --- */
    .flip-card-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        padding: 20px 0;
        /* By removing 'align-items: start', cards will stretch to equal height in each row */
    }
    .flip-card {
        display: grid; /* Use grid to stack front and back */
        grid-template-areas: "stack";
        cursor: pointer;
    }
    .flip-card-front, .flip-card-back {
        grid-area: stack; /* Place both front and back in the same grid area */
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        min-height: 150px; /* Set a minimum height but allow it to grow */
        box-sizing: border-box;
        font-size: 1rem;
        transition: opacity 0.4s ease;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    }
    .flip-card-front {
        background-color: #f8f9fa;
        color: var(--color-primary-text);
        opacity: 1;
        text-align: center;
        flex-direction: column; /* Stack title and subtitle vertically */
    }
    .flip-card-back {
        background-color: var(--color-card-bg);
        color: var(--color-primary-text);
        opacity: 0;
    }
    .flip-card.flipped .flip-card-front {
        opacity: 0;
    }
    .flip-card.flipped .flip-card-back {
        opacity: 1;
    }
    .flip-card-front p, .flip-card-back p {
        margin: 0;
    }
    /* --- End Flip Card Styles --- */
    
    #card-buttons {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 24px;
    }
    #card-buttons-left, #card-buttons-right {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
    }
    #card-buttons button {
      background: var(--color-accent); color: #fff; border: none; border-radius: 50px; padding: 10px 24px;
      font-size: 14px; font-family: var(--font-family); font-weight: 600; cursor: pointer; transition: background 0.2s, box-shadow 0.2s;
      box-shadow: 0 2px 8px 0 rgba(255,90,0,0.15);
    }
    #card-buttons button:hover { background: #e04e00; }
    .resource-link-btn {
      display: inline-flex; align-items: center; justify-content: center; gap: 10px; margin-top: 20px; padding: 12px 28px;
      background-color: var(--color-accent); color: white; text-decoration: none; border-radius: 50px; font-weight: 600;
      box-shadow: 0 2px 8px 0 rgba(255,90,0,0.2); transition: all 0.2s;
    }
    .resource-link-btn:hover { background-color: #e04e00; transform: translateY(-2px); box-shadow: 0 4px 12px 0 rgba(255,90,0,0.3); }

    #embed-panel { width: 48%; min-width: 420px; height: 100%; background: var(--color-card-bg); border-radius: 18px;
      box-shadow: 0 4px 32px 0 rgba(60,60,60,0.07); display: none; flex-direction: column; overflow: hidden; }
    #embed-panel.visible { display: flex; }
    #embed-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 14px; border-bottom: 1px solid #eee; gap: 8px; }
    #embed-title { font-weight: 600; }
    #embed-actions { display: flex; align-items: center; gap: 8px; }
    #embed-close { background: transparent; border: none; border-radius: 6px; width: 28px; height: 28px; cursor: pointer; font-size: 18px; line-height: 28px; }
    #embed-open-external { background: var(--color-accent); color: #fff; border: none; border-radius: 8px; padding: 6px 10px; cursor: pointer; font-weight: 600; }
    #embed-iframe { flex: 1 1 auto; width: 100%; border: 0; }
    
    /* Draggable divider between content and embed */
    #content-embed-resizer {
      width: 8px;
      cursor: col-resize;
      background: transparent;
      position: relative;
      z-index: 5;
      display: none; /* only visible when embed is visible */
    }
    #content-embed-resizer.visible { display: block; }
    #content-embed-resizer::after {
      content: '';
      position: absolute;
      top: 0; bottom: 0; left: 2px; right: 2px;
      border-radius: 2px;
      background: rgba(0,0,0,0.06);
      transition: background 0.2s;
    }
    #content-embed-resizer:hover::after { background: rgba(0,0,0,0.12); }

    .link { stroke: #999; stroke-opacity: 0.6; }
    .link.visited-main, .link.visited-sidequest { stroke: var(--color-visited-main); stroke-width: 2.5px; }
    .link.visited-sidequest { stroke-dasharray: 4 4; }
    .node circle {
        transition: all 0.2s; fill: var(--color-unvisited); cursor: pointer;
    }
    .node:hover circle { transform: scale(1.1); }
    .node.unvisited circle { fill: var(--color-unvisited); }
    .node.visited-main circle { fill: var(--color-visited-main); }
    .node.visited-sidequest circle { fill: var(--color-visited-sidequest); }
    .node.active circle { fill: var(--color-accent); filter: drop-shadow(0 0 10px var(--color-accent)); r: 15 !important; }
    
    .img-container {
      border-radius: 15px;
      overflow: hidden;
      box-shadow: 0 10px 25px rgba(0,0,0,0.08), 0 3px 8px rgba(0,0,0,0.08);
      background: #fff;
    }
    
    @media (max-width: 900px) {
        .flip-card-grid {
            grid-template-columns: 1fr;
        }
        /* Media query for responsive is unchanged */
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="flow-map-container">
      <svg id="flow-map-svg"></svg>
      <div id="tooltip"></div>
      <div id="resizer"></div>
      <button id="close-sidebar-btn" title="Close Flow Map">×</button>
    </div>
    <div id="content-area">
        <button id="open-sidebar-btn" title="Open Flow Map">➔</button>
        <div id="content-card">
            <div id="card-text-content">
                <h2 id="card-title">Loading...</h2>
                <div id="card-content"></div>
            </div>
            <div id="card-buttons"></div>
        </div>

        <div id="content-embed-resizer" aria-hidden="true"></div>

        <div id="embed-panel" aria-label="Embedded resource panel">
          <div id="embed-header">
            <span id="embed-title">Resource</span>
            <div id="embed-actions">
              <button id="embed-open-external" title="Open in new tab">Open in new tab</button>
              <button id="embed-close" title="Close">×</button>
            </div>
          </div>
          <iframe id="embed-iframe" allow="fullscreen; clipboard-write; autoplay; storage-access"></iframe>
        </div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
  <script>
    function renderContent(element, text, nodeType = 'main') {
        if (nodeType === 'flip-cards') {
            renderFlipCards(element, text);
            return;
        }
        let content = text || '';
        // Strip any leading header tags like [title:], [next:], [prev:] that may remain in card content
        content = content.replace(/^(?:\s*\[(?:title|next|prev):[^\]]+\]\s*\n)+/i, '');
        // Clear any previous resource metadata on this element
        try {
          element.removeAttribute('data-resource-url');
          element.removeAttribute('data-resource-title');
          element.removeAttribute('data-buttons');
          element.innerHTML = '';
        } catch (_) {}

        // Detect and render [quote] blocks first
        const quoteRegex = /\[quote\][\s\S]*?\[\/quote\]/g;
        const hasQuote = quoteRegex.test(content);
        if (hasQuote) {
          const parts = content.split(quoteRegex);
          const quotes = content.match(quoteRegex) || [];
          // Render non-quote parts normally and quotes as components, sequentially
          let html = '';
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (part && part.trim()) {
              const temp = document.createElement('div');
              renderContentNormal(temp, part.trim());
              html += temp.innerHTML;
            }
            const q = quotes[i];
            if (q) {
              const textMatch = q.match(/text:\s*(.*)/);
              const authorMatch = q.match(/author:\s*(.*)/);
              const qText = textMatch ? textMatch[1].trim() : '';
              const qAuthor = authorMatch ? authorMatch[1].trim() : '';
              html += `<div class="quote-block"><div class="quote-mark">❝</div><div><div class="quote-text">${qText}</div>${qAuthor ? `<div class="quote-author">— ${qAuthor}</div>` : ''}</div></div>`;
            }
          }
          element.innerHTML = html;
          return;
        }

        // Extract inline button syntax: [button:Label](https://...)
        const buttonRegex = /\[button:([^\]]+)\]\((https?:\/\/[^\s)]+)\)/gi;
        const buttonDefs = [];
        let strippedContent = content.replace(buttonRegex, (m, label, url) => {
          buttonDefs.push({ buttonText: label.trim(), url: url.trim() });
          return '';
        }).trim();

        // Normalize alias syntax: [image/...](file) or [video/...](file) -> ![image/...](file)
        strippedContent = strippedContent.replace(/\[(image|video)([^\]]*)\]\(([^)]+)\)/gi, '![$1$2]($3)');

        // --- Handle special content types first (YouTube, links) ---
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
        const youtubeMatch = strippedContent.match(youtubeRegex);
        if (youtubeMatch) {
            const videoId = youtubeMatch[1];
            element.innerHTML = `<div style="position: relative; width: 100%; padding-top: 56.25%; background: #eee; border-radius: 8px; overflow: hidden;"><iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" src="https://www.youtube.com/embed/${videoId}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`;
            if (buttonDefs.length) element.setAttribute('data-buttons', JSON.stringify(buttonDefs));
            return;
        }
        if (strippedContent.startsWith('http://') || strippedContent.startsWith('https://')) {
            // Store URL on the content element; we'll render the button in the buttons area instead
            element.innerHTML = '';
            element.setAttribute('data-resource-url', strippedContent);
            element.setAttribute('data-resource-title', 'Open Resource');
            if (buttonDefs.length) element.setAttribute('data-buttons', JSON.stringify(buttonDefs));
            return;
        }
 
        // Check if we have any stacked-right images
        const imageRegex = /!\[(.*?)\]\(([^)\s]+)\)/g;
        const allImages = [...strippedContent.matchAll(imageRegex)];
        const hasStackedMedia = allImages.some(img => {
            const attrs = img[1].split('/').slice(1);
            return attrs.some(attr => attr.includes('align:stack-right'));
        });
 
        if (hasStackedMedia) {
            renderContentWithStackedImages(element, strippedContent);
        } else {
            renderContentNormal(element, strippedContent);
        }
        if (buttonDefs.length) element.setAttribute('data-buttons', JSON.stringify(buttonDefs));
    }

    function renderContentWithStackedImages(element, content) {
        const lines = content.split('\n');
        let textHtml = '';
        let stackedMedia = [];
        let inList = false;
        const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

        for (const line of lines) {
            const trimmedLine = line.trim();
            const isListItem = trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ') || trimmedLine.startsWith('-');

            const mediaRegex = /!\[(.*?)\]\(([^)\s]+)\)/g;
            const mediaItems = [...line.matchAll(mediaRegex)];

            if (mediaItems.length > 0) {
                // Check if this line has stacked-right media
                let hasStackedOnThisLine = false;
                mediaItems.forEach(match => {
                    const allData = match[1].split('/');
                    const attributes = allData.slice(1);
                    const isStacked = attributes.some(attr => attr.includes('align:stack-right'));
                    
                    if (isStacked) {
                        hasStackedOnThisLine = true;
                        const typeAndAlt = allData[0].split(':');
                        const isVideo = typeAndAlt[0] === 'video';
                        const altText = isVideo ? typeAndAlt.slice(1).join(':').trim() : allData[0].trim();
                        
                        const v = (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? Date.now() : '1.0';
                        const src = `images/${match[2]}?v=${v}`;
                        
                        let sizeClass = 'size-medium';
                        let style = '';
                        let frameClass = '';
                        attributes.forEach(attr => {
                            const [key, value] = attr.split(':');
                            if (key.trim() === 'size') {
                                const sizeValue = value.trim();
                                if (sizeValue.endsWith('px')) {
                                    style = `height: ${sizeValue}; width: auto;`;
                                    sizeClass = '';
                                } else {
                                    sizeClass = `size-${sizeValue}`;
                                }
                            } else if (key.trim() === 'frame' || key.trim() === 'border' || key.trim() === 'style') {
                                const v = (value || '').trim().toLowerCase();
                                if (v === 'none' || v === 'no' || v === 'off' || v === 'plain' || v === '0') {
                                    frameClass = 'no-frame';
                                }
                            }
                        });
                        
                        if (isVideo) {
                            stackedMedia.push(`<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><video autoplay loop muted playsinline style=\"width:100%;height:auto;\" src=\"${src}\" title=\"${altText}\"></video></div>`);
                        } else {
                            stackedMedia.push(`<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><img src=\"${src}\" alt=\"${altText}\" style=\"${style}\"></div>`);
                        }
                    }
                });

                // If line has non-stacked media, process them normally
                if (!hasStackedOnThisLine) {
                    let combinedAttrs = [];
                    mediaItems.forEach(match => {
                        const allData = match[1].split('/');
                        const attributes = allData.slice(1);
                        combinedAttrs = combinedAttrs.concat(attributes);
                    });

                    let alignClass = 'align-center';
                    combinedAttrs.forEach(attr => {
                        const [key, value] = attr.split(':');
                        if (key === 'align') {
                            alignClass = `align-${value.trim()}`;
                        }
                    });

                    let mediaHtml = `<div class="content-images-container ${alignClass}">`;
                    mediaItems.forEach(match => {
                        const allData = match[1].split('/');
                        const typeAndAlt = allData[0].split(':');
                        const isVideo = typeAndAlt[0] === 'video';
                        const altText = isVideo ? typeAndAlt.slice(1).join(':').trim() : allData[0].trim();
                        const attributes = allData.slice(1);
                        const v = (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? Date.now() : '1.0';
                        const src = `images/${match[2]}?v=${v}`;
                        
                        let sizeClass = 'size-large';
                        let style = '';
                        let frameClass = '';
                        attributes.forEach(attr => {
                            const [key, value] = attr.split(':');
                            if (key.trim() === 'size') {
                                const sizeValue = value.trim();
                                if (sizeValue.endsWith('px')) {
                                    style = `height: ${sizeValue}; width: auto;`;
                                    sizeClass = '';
                                } else {
                                    sizeClass = `size-${sizeValue}`;
                                }
                            } else if (key.trim() === 'frame' || key.trim() === 'border' || key.trim() === 'style') {
                                const v = (value || '').trim().toLowerCase();
                                if (v === 'none' || v === 'no' || v === 'off' || v === 'plain' || v === '0') {
                                    frameClass = 'no-frame';
                                }
                            }
                        });
                        if (isVideo) {
                            mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><video autoplay loop muted playsinline style=\"width:100%;height:auto;\" src=\"${src}\" title=\"${altText}\"></video></div>`;
                        } else {
                            mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><img src=\"${src}\" alt=\"${altText}\" style=\"${style}\"></div>`;
                        }
                    });
                    mediaHtml += '</div>';
                    textHtml += mediaHtml;
                }
            } else if (isListItem) {
                if (!inList) {
                    textHtml += '<ul>';
                    inList = true;
                }
                const listItemContent = processBold(trimmedLine.startsWith('- ') ? trimmedLine.substring(2) : trimmedLine.substring(1));
                textHtml += `<li>${listItemContent}</li>`;
            } else {
                if (inList) {
                    textHtml += '</ul>';
                    inList = false;
                }
                if (trimmedLine === '' && textHtml.length > 0) {
                    textHtml += '<p> </p>';
                } else if (trimmedLine !== '') {
                    textHtml += `<p>${processBold(line)}</p>`;
                }
            }
        }

        if (inList) {
            textHtml += '</ul>';
        }

        // Create the layout with text on left and stacked images on right
        const stackedMediaHtml = stackedMedia.length > 0 ? 
            `<div class="stacked-images">${stackedMedia.join('')}</div>` : '';

        element.innerHTML = `
            <div class="content-with-stacked-images">
                <div class="text-content">${textHtml}</div>
                ${stackedMediaHtml}
            </div>
        `;
    }

    function renderContentNormal(element, content) {
        let html = '';
        const lines = content.split('\n');
        let inList = false;
        const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

        for (const line of lines) {
            const trimmedLine = line.trim();
            const isListItem = trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ') || trimmedLine.startsWith('-');

            if (isListItem) {
                if (!inList) {
                    html += '<ul>';
                    inList = true;
                }
                const listItemContent = processBold(trimmedLine.startsWith('- ') ? trimmedLine.substring(2) : trimmedLine.substring(1));
                html += `<li>${listItemContent}</li>`;
            } else {
                if (inList) {
                    html += '</ul>';
                    inList = false;
                }

                const imageRegex = /!\[(.*?)\]\(([^)\s]+)\)/g;
                const mediaItems = [...line.matchAll(imageRegex)];

                if (mediaItems.length > 0) {
                    let combinedAttrs = [];
                    mediaItems.forEach(imgMatch => {
                        const allData = imgMatch[1].split('/');
                        const attributes = allData.slice(1);
                        combinedAttrs = combinedAttrs.concat(attributes);
                    });

                    let alignClass = 'align-center';
                    combinedAttrs.forEach(attr => {
                        const [key, value] = attr.split(':');
                        if (key === 'align') {
                            alignClass = `align-${value.trim()}`;
                        }
                    });

                    let mediaHtml = `<div class="content-images-container ${alignClass}">`;

                    mediaItems.forEach(match => {
                        const allData = match[1].split('/');
                        const typeAndAlt = allData[0].split(':');
                        const isVideo = typeAndAlt[0] === 'video';
                        const altText = isVideo ? typeAndAlt.slice(1).join(':').trim() : allData[0].trim();
                        const attributes = allData.slice(1);
                        const v = (location.hostname === 'localhost' || location.hostname === '127.0.0.1') ? Date.now() : '1.0';
                        const src = `images/${match[2]}?v=${v}`;
                        
                        let sizeClass = 'size-large';
                        let style = '';
                        let frameClass = '';

                        attributes.forEach(attr => {
                            const [key, value] = attr.split(':');
                            if (key.trim() === 'size') {
                                const sizeValue = value.trim();
                                if (sizeValue.endsWith('px')) {
                                    style = `height: ${sizeValue}; width: auto;`;
                                    sizeClass = '';
                                } else {
                                    sizeClass = `size-${sizeValue}`;
                                }
                            } else if (key.trim() === 'frame' || key.trim() === 'border' || key.trim() === 'style') {
                                const v = (value || '').trim().toLowerCase();
                                if (v === 'none' || v === 'no' || v === 'off' || v === 'plain' || v === '0') {
                                    frameClass = 'no-frame';
                                }
                            }
                        });
                        if (isVideo) {
                           mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><video autoplay loop muted playsinline style=\"width:100%;height:auto;\" src=\"${src}\" title=\"${altText}\"></video></div>`;
                        } else {
                           mediaHtml += `<div class=\"img-container ${sizeClass} ${frameClass}\" style=\"${style}\"><img src=\"${src}\" alt=\"${altText}\" style=\"${style}\"></div>`;
                        }
                    });
                    mediaHtml += '</div>';
                    html += mediaHtml;
                } else if (trimmedLine === '' && html.length > 0) {
                    html += '<p> </p>';
                } else if (trimmedLine !== '') {
                    html += `<p>${processBold(line)}</p>`;
                }
            }
        }

        if (inList) {
            html += '</ul>'; // Close any list that's still open
        }

        element.innerHTML = html;
    }

    function renderFlipCards(element, text) {
        const cardsData = [];
        // Split cards by the new, unique separator
        let introHtml = '';
        let working = text || '';
        const introMatch = working.match(/\[intro\]\n([\s\S]*?)\n\[\/intro\]\n?/);
        if (introMatch) {
            const introText = introMatch[1].trim();
            const temp = document.createElement('div');
            renderContentNormal(temp, introText);
            introHtml = temp.innerHTML;
            working = working.replace(introMatch[0], '');
        }
        const cardBlocks = working.split('[card-separator]');
        const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        
        cardBlocks.forEach(block => {
            const trimmedBlock = block.trim();
            if (!trimmedBlock.startsWith('[card]')) return;

            let front = 'Click to reveal';
            let back = '';
            
            const lines = trimmedBlock.split('\n').slice(1); // Skip the [card] line
            let currentKey = '';
            let contentBuffer = '';

            lines.forEach(line => {
                const frontMatch = line.match(/^front:\s*(.*)/);
                const backMatch = line.match(/^back:\s*(.*)/);

                if (frontMatch) {
                    if (currentKey === 'back') { // Finished back content
                        back = contentBuffer.trim();
                        contentBuffer = '';
                    }
                    currentKey = 'front';
                    contentBuffer = frontMatch[1];
                } else if (backMatch) {
                    if (currentKey === 'front') { // Finished front content
                        front = contentBuffer.trim();
                        contentBuffer = '';
                    }
                    currentKey = 'back';
                    contentBuffer = backMatch[1];
                } else {
                    contentBuffer += '\n' + line;
                }
            });

            // Capture the last piece of content
            if (currentKey === 'front') {
                front = contentBuffer.trim();
            } else if (currentKey === 'back') {
                back = contentBuffer.trim();
            }

            // Use default if front is empty
            if (!front) {
                front = 'Click to reveal';
            }

            cardsData.push({ front, back });
        });

        let html = '';
        if (introHtml) {
            html += `<div style="margin-bottom: 12px;">${introHtml}</div>`;
        }
        html += '<div class="flip-card-grid">';
        cardsData.forEach(card => {
            // New logic to handle title and subtitle for the front of the card
            const frontParts = card.front.split('\n');
            const frontTitle = frontParts[0];
            const frontSubtitle = frontParts.slice(1).join('<br>');

            let frontHtml = `<p><strong>${processBold(frontTitle)}</strong></p>`;
            if (frontSubtitle) {
                frontHtml += `<p style="font-size: 0.8em; opacity: 0.7; margin-top: 8px;">${processBold(frontSubtitle)}</p>`;
            }

            html += `
                <div class="flip-card" onclick="this.classList.toggle('flipped')">
                    <div class="flip-card-front">
                        ${frontHtml}
                    </div>
                    <div class="flip-card-back">
                        <p>${processBold(card.back)}</p>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        element.innerHTML = html;
    }

    function openInEmbed(url, title = 'Resource') {
      const panel = document.getElementById('embed-panel');
      const iframe = document.getElementById('embed-iframe');
      const titleEl = document.getElementById('embed-title');
      const resizer = document.getElementById('content-embed-resizer');
      const contentCard = document.getElementById('content-card');
      if (!panel || !iframe) { window.open(url, '_blank'); return; }
      titleEl.textContent = title;
      iframe.src = url;
      panel.classList.add('visible');
      if (resizer) resizer.classList.add('visible');
      // Ensure we have sensible initial split if not set yet
      if (contentCard && !contentCard.style.width) {
        contentCard.style.width = '50%';
      }
      if (!panel.style.width) {
        panel.style.width = '50%';
      }
    }

    function handleResourceClick(e, url, title) {
      if (e && (e.metaKey || e.ctrlKey || e.shiftKey || e.button === 1)) {
        window.open(url, '_blank');
        return false;
      }
      try {
        const parsed = new URL(url, window.location.href);
        const host = parsed.hostname || '';
        const isTargetInact = host.endsWith('inactnow.io');
        const isCurrentInact = (window.location.hostname || '').endsWith('inactnow.io');
        // If cross-site relative to inactnow.io, open in new tab to avoid cookie blocking; if same-site, keep in embed
        if (isTargetInact && !isCurrentInact) {
          window.open(url, '_blank');
          return false;
        }
      } catch (_) { /* ignore URL parse errors and fallback to embed */ }
      openInEmbed(url, title || 'Resource');
      return false;
    }

    document.addEventListener('DOMContentLoaded', () => {
             const closeBtn = document.getElementById('embed-close');
       const openExternalBtn = document.getElementById('embed-open-external');
       if (closeBtn) {
         closeBtn.addEventListener('click', () => {
           const panel = document.getElementById('embed-panel');
           const iframe = document.getElementById('embed-iframe');
           const resizer = document.getElementById('content-embed-resizer');
           const contentCard = document.getElementById('content-card');
           if (iframe) iframe.src = 'about:blank';
           if (panel) panel.classList.remove('visible');
           if (resizer) resizer.classList.remove('visible');
           // Reset widths so the info-card returns to full size
           if (contentCard) contentCard.style.width = '';
           if (panel) panel.style.width = '';
         });
       }
       if (openExternalBtn) {
         openExternalBtn.addEventListener('click', () => {
           const iframe = document.getElementById('embed-iframe');
           const url = iframe && iframe.src ? iframe.src : null;
           if (url) window.open(url, '_blank');
         });
       }

      // Drag-to-resize between content and embed
      const resizer = document.getElementById('content-embed-resizer');
      const contentArea = document.getElementById('content-area');
      const contentCard = document.getElementById('content-card');
      const embedPanel = document.getElementById('embed-panel');
      let isDragging = false;

      function onPointerDown(e) {
        if (!embedPanel.classList.contains('visible')) return;
        isDragging = true;
        document.body.style.cursor = 'col-resize';
        e.preventDefault();
      }
      function onPointerMove(e) {
        if (!isDragging) return;
        const containerRect = contentArea.getBoundingClientRect();
        const minLeft = containerRect.left + 300; // min width for content card
        const maxLeft = containerRect.right - 420; // min width for embed panel
        let x = e.clientX;
        if (x < minLeft) x = minLeft;
        if (x > maxLeft) x = maxLeft;
        const leftWidth = x - containerRect.left;
        const rightWidth = containerRect.right - x;
        contentCard.style.width = leftWidth + 'px';
        embedPanel.style.width = rightWidth + 'px';
      }
      function onPointerUp() {
        if (!isDragging) return;
        isDragging = false;
        document.body.style.cursor = 'default';
      }

      if (resizer) {
        resizer.addEventListener('mousedown', onPointerDown);
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        // touch support
        resizer.addEventListener('touchstart', (e) => onPointerDown(e.touches[0]));
        window.addEventListener('touchmove', (e) => onPointerMove(e.touches[0]));
        window.addEventListener('touchend', onPointerUp);
      }
    });

    // --- START: NEW, MORE ROBUST PARSER ---
    function parseFlowScript(text) {
        const sideQuestContentMap = new Map();
        const mainNodes = [];
        let currentBlock = null;

        // First pass to extract side quest content blocks, which are self-contained
        const sqRegex = /\[side-quest-content:([^\]]+)\]\s*\n---\n([\s\S]*?)\n---/g;
        let remainingText = text.replace(sqRegex, (match, fullType, content) => {
            // fullType can be like "type:title|next=...|back=..."
            const firstColon = fullType.indexOf(':');
            const type = firstColon >= 0 ? fullType.slice(0, firstColon).trim() : fullType.trim();
            const rest = firstColon >= 0 ? fullType.slice(firstColon + 1) : '';
            const barIdx = rest.indexOf('|');
            const title = (barIdx >= 0 ? rest.slice(0, barIdx) : rest).trim();
            const optsStr = barIdx >= 0 ? rest.slice(barIdx + 1) : '';
            const opts = {};
            optsStr.split('|').forEach(p => {
                const [k, ...vparts] = p.split('=');
                if (!k || vparts.length === 0) return;
                opts[k.trim()] = vparts.join('=').trim();
            });
            const raw = (content || '').trim();
            const partsArr = raw.length ? raw.split(/\n\[sq-card-separator\]\n/) : [''];
            const cardObjs = partsArr.map(p => {
                let t = p.trim();
                let nextLabel = '';
                let prevLabel = '';
                const lines = t.split('\n');
                while (lines.length && /^\[(next|prev):/.test(lines[0].trim())) {
                    const m = lines.shift().trim().match(/^\[(next|prev):\s*(.+?)\]$/);
                    if (m) {
                        if (m[1] === 'next') nextLabel = m[2]; else prevLabel = m[2];
                    } else { break; }
                }
                return { content: lines.join('\n').trim(), nextLabel, prevLabel };
            });
            const key = title ? `${type}:${title}` : type;
            sideQuestContentMap.set(key, { cards: cardObjs, nextLabel: opts.next || '', backLabel: opts.back || '' });
            return ''; // Remove the block from the text
        });

        // Second, line-by-line pass for main nodes
        const lines = remainingText.split('\n');
        let isContent = false;
        
        for (const line of lines) {
            if (line.trim().startsWith('id:')) {
                // Finish previous node before starting a new one
                if (currentBlock) mainNodes.push(currentBlock);
                currentBlock = { connections: {}, sideQuests: [] };
                isContent = false;
            }

            if (!currentBlock) continue;

            if (line.trim() === '---') {
                isContent = !isContent;
                continue;
            }

            if (isContent) {
                currentBlock.content = (currentBlock.content || '') + line + '\n';
            } else {
                if (line.startsWith('>')) {
                    const mainMatch = line.match(/>\s*(.+?)\s*->\s*(\d+)/);
                    const sqMatch = line.match(/>\s*(.+?)\s*->\s*\[(video|now|case):(.+?)\]/);
                    const linkMatch = line.match(/>\s*(.+?)\s*->\s*\[link:(newtab|embed)?:?(.+?)\]/);
                    if (mainMatch) {
                        currentBlock.connections[mainMatch[1].trim()] = parseInt(mainMatch[2]);
                    } else if (sqMatch) {
                        const [, buttonText, type, title] = sqMatch;
                        // Try multiple matching strategies for content lookup
                        let meta = sideQuestContentMap.get(`${type}:${title}`);
                        
                        if (!meta) {
                            // Try to find content by partial title match (for legacy compatibility)
                            for (const [key, value] of sideQuestContentMap.entries()) {
                                if (key.startsWith(`${type}:`)) {
                                    const keyTitle = key.split(':', 2)[1];
                                    // Check if either title contains the other (partial match)
                                    if (title.includes(keyTitle) || keyTitle.includes(title)) {
                                        meta = value;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (!meta) {
                            // Final fallback to type-only match
                            meta = sideQuestContentMap.get(type) || { cards: [''], nextLabel: '', backLabel: '' };
                        }
                        
                        const cards = Array.isArray(meta) ? meta : (meta.cards || ['']);
                        const nextLabel = meta.nextLabel || '';
                        const backLabel = meta.backLabel || '';
                        currentBlock.sideQuests.push({ type, title, buttonText, cards, nextLabel, backLabel });
                    } else if (linkMatch) {
                        const [, buttonText, targetOpt, url] = linkMatch;
                        if (!currentBlock.links) currentBlock.links = [];
                        currentBlock.links.push({ buttonText: buttonText.trim(), url: url.trim().replace(/\]$/, ''), target: (targetOpt || 'newtab').trim() });
                    }
                } else {
                    const [key, ...valueParts] = line.split(':');
                    if (valueParts.length > 0) {
                        const value = valueParts.join(':').trim();
                        currentBlock[key.trim()] = key.trim() === 'id' ? parseInt(value) : value;
                    }
                }
            }
        }
        // Add the last node to the array
        if (currentBlock) mainNodes.push(currentBlock);

        // Clean up the content for each node
        mainNodes.forEach(node => {
            if (node.content) node.content = node.content.trim();
        });
        
        return mainNodes;
    }
    // --- END: NEW, MORE ROBUST PARSER ---
    
    // The main execution block (no changes needed here)
    (async function() {
        let courseData;
        try {
            const urlParams = new URLSearchParams(window.location.search);
            const courseFile = urlParams.get('course') || 'Intro.txt';
            const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            const cacheParam = isLocal ? Date.now() : '1.0';
            const response = await fetch(`courses/${courseFile}?v=${cacheParam}`); // Cache-busting
            if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
            const text = await response.text();
            courseData = parseFlowScript(text);
            if (!courseData || courseData.length === 0) { throw new Error("Parsing resulted in no valid course data."); }
        } catch (error) {
            console.error('Error loading or parsing course file:', error);
            document.getElementById('card-title').textContent = 'Error';
            document.getElementById('card-content').innerHTML = 'Could not load the course. Please check that <strong>course.txt</strong> exists and is valid. Remember to use a local server.';
            return;
        }

        const firstNode = courseData.find(n => n && n.id != null);
        let activeNodeId = String(firstNode ? firstNode.id : '1'); let visitedNodes = new Set([activeNodeId]);
        const svgContainer = d3.select('#flow-map-container'); const svg = d3.select('#flow-map-svg'); const g = svg.append('g'); const tooltip = d3.select('#tooltip');
        const d3Nodes = [], d3Links = [], nodeById = new Map();

        courseData.forEach(mainNodeData => {
            if (!mainNodeData.id) return; // Skip invalid nodes
            const mainNode = { ...mainNodeData, id: String(mainNodeData.id) }; delete mainNode.sideQuests;
            d3Nodes.push(mainNode); nodeById.set(mainNode.id, mainNode);
            if (mainNodeData.sideQuests) {
                mainNodeData.sideQuests.forEach((sqData, index) => {
                    const cards = Array.isArray(sqData.cards) && sqData.cards.length ? sqData.cards : [sqData.content || ''];
                    let previousId = null;
                    const hasMultiple = cards.length > 1;
                    const randLeftRight = (((parseInt(mainNodeData.id, 10) || 0) * 9301 + index * 49297) % 2) === 0 ? -1 : 1;
                    const branchDir = hasMultiple ? 1 : randLeftRight; // multi: always right, single: random left/right
                    cards.forEach((card, cardIdx) => {
                        const cardContent = typeof card === 'object' ? (card.content || '') : card;
                        const cardNext = typeof card === 'object' ? (card.nextLabel || '') : '';
                        const cardPrev = typeof card === 'object' ? (card.prevLabel || '') : '';
                        const sideQuestId = `${mainNodeData.id}-${sqData.type}-${index}-${cardIdx}`;
                        const titleSuffix = cards.length > 1 ? ` (${cardIdx + 1}/${cards.length})` : '';
                        const cardTitle = typeof card === 'object' ? (card.title || '') : (sqData.title || '');
                        const sideQuestNode = { ...sqData, id: sideQuestId, type: 'sidequest', parentId: String(mainNodeData.id), content: cardContent, cardIndex: cardIdx, numCards: cards.length, title: cardTitle, buttonText: sqData.buttonText + titleSuffix, nextLabel: cardNext || sqData.nextLabel || '', backLabel: cardPrev || sqData.backLabel || '', prevId: previousId || null, nextId: null, branchDir };
                        d3Nodes.push(sideQuestNode); nodeById.set(sideQuestNode.id, sideQuestNode);
                        if (previousId) { d3Links.push({ source: previousId, target: sideQuestId }); const prevNode = nodeById.get(previousId); if (prevNode) prevNode.nextId = sideQuestId; }
                        else { d3Links.push({ source: String(mainNodeData.id), target: sideQuestId }); }
                        previousId = sideQuestId;
                    });
                });
            }
            Object.values(mainNodeData.connections).forEach(targetId => { d3Links.push({ source: mainNode.id, target: String(targetId) }); });
        });

        let width = svgContainer.node().getBoundingClientRect().width; let height = svgContainer.node().getBoundingClientRect().height;
        
        function updateMainPathPositions() {
            width = svgContainer.node().getBoundingClientRect().width; height = svgContainer.node().getBoundingClientRect().height; if (width === 0 || height === 0) return;
            svg.attr('viewBox', `0 0 ${width} ${height}`);
            const mainPath = d3Nodes.filter(n => n.type === 'main' || n.type === 'flip-cards'); const mainYStep = (height * 0.9) / (mainPath.length > 1 ? mainPath.length - 1 : 1);
            mainPath.forEach((n, i) => { n.fy = height * 0.05 + i * mainYStep; n.fx = width / 2; });
            updateSideQuestPositions();
        }
        updateMainPathPositions();

        function updateSideQuestPositions() {
            const baseHorizontal = Math.max(120, Math.min(220, Math.round(width * 0.18)));
            const verticalStep = 72;
            d3Nodes.forEach(n => {
                if (n.type === 'sidequest') {
                    const parent = nodeById.get(String(n.parentId));
                    if (parent && typeof parent.fy !== 'undefined' && typeof parent.fx !== 'undefined') {
                        const idx = typeof n.cardIndex === 'number' ? n.cardIndex : 0;
                        const dir = n.branchDir || 1; // 1=right, -1=left
                        const t = (idx + 1) / Math.max(2, (n.numCards || 2));
                        const arcPush = Math.sin(t * Math.PI) * 30; // arched curve feel
                        const jitterSeed = ((parseInt(n.parentId, 10) || 0) * 8341 + idx * 2718) % 7;
                        const jitterX = (jitterSeed - 3) * 1.2;
                        const jitterY = ((jitterSeed * 2) % 5 - 2) * 1.2;
                        n.targetFx = parent.fx + dir * (baseHorizontal + arcPush) + jitterX;
                        n.targetFy = parent.fy + (idx + 1) * verticalStep + jitterY;
                        if (typeof n.x === 'undefined' || typeof n.y === 'undefined') {
                            n.x = n.targetFx; n.y = n.targetFy;
                        }
                    }
                }
            });
        }

        const simulation = d3.forceSimulation(d3Nodes)
          .force('link', d3.forceLink(d3Links).id(d => d.id).distance(80).strength(0.8))
          .force('charge', d3.forceManyBody().strength(-450))
          .force('collide', d3.forceCollide(20))
          .force('sqX', d3.forceX(d => (d.type === 'sidequest' && typeof d.targetFx === 'number') ? d.targetFx : (typeof d.fx === 'number' ? d.fx : width / 2)).strength(d => d.type === 'sidequest' ? 0.08 : 0))
          .force('sqY', d3.forceY(d => (d.type === 'sidequest' && typeof d.targetFy === 'number') ? d.targetFy : (typeof d.fy === 'number' ? d.fy : height / 2)).strength(d => d.type === 'sidequest' ? 0.12 : 0));
        const link = g.append('g').attr('class', 'links').selectAll('line').data(d3Links).join('line').attr('class', 'link');
        const node = g.append('g').attr('class', 'nodes').selectAll('g').data(d3Nodes).join('g').attr('class', 'node')
          .on('click', (event, d) => updateView(d.id))
          .on('mouseover', function(event, d) { tooltip.style('visibility', 'visible').style('opacity', 1); tooltip.html(`<div class="tooltip-title">${d.title}</div><div class="tooltip-type">${d.type === 'sidequest' ? `▶ ${d.type.charAt(0).toUpperCase() + d.type.slice(1)}` : 'ⓘ Main Step'}</div>`); })
          .on('mousemove', function(event) { const [x, y] = d3.pointer(event, document.body); tooltip.style('left', (x + 20) + 'px').style('top', (y + 20) + 'px'); })
          .on('mouseout', function() { tooltip.style('visibility', 'hidden').style('opacity', 0); });
        node.append('circle').attr('r', 12);
        const zoom = d3.zoom().scaleExtent([0.5, 3]).on('zoom', (event) => { g.attr('transform', event.transform); simulation.alpha(0.04).restart(); }); svg.call(zoom);

        function centerNode(nodeId) {
            const targetNode = nodeById.get(nodeId); if (!targetNode || typeof targetNode.x === 'undefined') return;
            const currentTransform = d3.zoomTransform(svg.node());
            const targetX = -targetNode.x * currentTransform.k + width / 2; const targetY = -targetNode.y * currentTransform.k + height / 2;
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity.translate(targetX, targetY).scale(currentTransform.k));
        }
        simulation.on('tick', () => {
          link.attr('x1', d => d.source.x).attr('y1', d => d.source.y).attr('x2', d => d.target.x).attr('y2', d => d.target.y);
          node.attr('transform', d => `translate(${d.x},${d.y})`);
        });

        function updateView(nodeId) {
          activeNodeId = nodeId; visitedNodes.add(nodeId);
          const n = nodeById.get(nodeId);
          if(!n) { console.error(`Node with id "${nodeId}" not found.`); return; }
          
          // Scroll to top of content area when navigating to a new node
          const contentArea = document.getElementById('content-area');
          if (contentArea) {
            contentArea.scrollTop = 0;
          }
          
          const cardTitleEl = document.getElementById('card-title');
          // Fallback extractors in case meta wasn't propagated
          const extractHeader = (source, key) => {
            if (!source) return '';
            const re = new RegExp("(?:^|\\n)\\[" + key + ":\\s*([^\\]]+)\\]", 'i');
            const m = source.match(re);
            return m ? m[1].trim() : '';
          };
          const effectiveTitle = (n.title && n.title.trim().length) ? n.title : extractHeader(n.content, 'title');
          const effectiveNext = (n.nextLabel && n.nextLabel.trim().length) ? n.nextLabel : extractHeader(n.content, 'next');

          if (n.type === 'sidequest') {
            if (effectiveTitle && effectiveTitle.trim() !== '') {
              const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
              cardTitleEl.innerHTML = processBold(effectiveTitle);
              cardTitleEl.style.display = '';
            } else {
              cardTitleEl.textContent = '';
              cardTitleEl.style.display = 'none';
            }
          } else if (n.title && n.title.trim() !== '') {
            const processBold = (str) => str.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            cardTitleEl.innerHTML = processBold(n.title);
            cardTitleEl.style.display = '';
          } else {
            cardTitleEl.textContent = '';
            cardTitleEl.style.display = 'none';
          }

          const cardContentEl = document.getElementById('card-content');
          renderContent(cardContentEl, n.content, n.type);

          const btnsContainer = document.getElementById('card-buttons');
          btnsContainer.innerHTML = `
              <div id="card-buttons-left"></div>
              <div id="card-buttons-right"></div>
          `;
          const leftButtons = btnsContainer.querySelector('#card-buttons-left');
          const rightButtons = btnsContainer.querySelector('#card-buttons-right');

          // If the card content stored a top-level resource URL (content was a bare URL),
          // render an "Open Resource" button in the bottom-left, regardless of node type.
          const cardContentElRef = document.getElementById('card-content');
          const resourceUrl = cardContentElRef.getAttribute('data-resource-url');
          const resourceTitle = cardContentElRef.getAttribute('data-resource-title') || 'Open Resource';
          const inlineButtonsJson = cardContentElRef.getAttribute('data-buttons');
          if (inlineButtonsJson) {
              try {
                  const btns = JSON.parse(inlineButtonsJson);
                  btns.forEach(b => {
                      const ib = document.createElement('button');
                      ib.textContent = b.buttonText || 'Open';
                      ib.onclick = (ev) => { ev && ev.preventDefault && ev.preventDefault(); openInEmbed(b.url, b.buttonText || 'Open'); };
                      leftButtons.appendChild(ib);
                  });
              } catch (_) {}
              cardContentElRef.removeAttribute('data-buttons');
          }
          if (resourceUrl) {
              const btn = document.createElement('button');
              btn.textContent = resourceTitle;
              btn.onclick = (ev) => handleResourceClick(ev, resourceUrl, resourceTitle);
              leftButtons.appendChild(btn);
              // Clear after consuming so subsequent nodes don't inherit
              cardContentElRef.removeAttribute('data-resource-url');
              cardContentElRef.removeAttribute('data-resource-title');
          }
 
          if (n.type === 'main' || n.type === 'flip-cards') {
              const mainNodeData = courseData.find(d => String(d.id) === n.id);
              if (mainNodeData && mainNodeData.sideQuests) {
                  mainNodeData.sideQuests.forEach((sq, index) => {
                      const btn = document.createElement('button');
                      btn.textContent = sq.buttonText;
                      btn.onclick = () => updateView(`${n.id}-${sq.type}-${index}-0`);
                      leftButtons.appendChild(btn);
                  });
              }
              if (mainNodeData && mainNodeData.links) {
                  mainNodeData.links.forEach(link => {
                      const btn = document.createElement('button');
                      btn.textContent = link.buttonText;
                      btn.onclick = (ev) => {
                          if ((link.target || 'newtab') === 'embed') {
                              // Force embed regardless of modifier keys
                              openInEmbed(link.url, link.buttonText);
                              return;
                          }
                          // Default: new tab
                          window.open(link.url, '_blank');
                      };
                      leftButtons.appendChild(btn);
                  });
              }
              for (const [label, targetId] of Object.entries(n.connections)) {
                  const btn = document.createElement('button');
                  btn.textContent = label;
                  btn.onclick = () => updateView(String(targetId));
                  rightButtons.appendChild(btn);
              }
                    } else if (n.type === 'sidequest') {
              if (n.prevId) {
                const prevBtn = document.createElement('button');
                prevBtn.textContent = n.backLabel || '◀ Previous';
                prevBtn.onclick = () => updateView(n.prevId);
                leftButtons.appendChild(prevBtn);
              }
              if (n.nextId) {
                const nextBtn = document.createElement('button');
                nextBtn.textContent = (effectiveNext && effectiveNext.trim().length) ? effectiveNext : ((n.nextLabel && n.nextLabel.trim().length) ? n.nextLabel : 'Next ▶');
                nextBtn.onclick = () => updateView(n.nextId);
                leftButtons.appendChild(nextBtn);
              }
              const btn = document.createElement('button');
              btn.textContent = n.backToMainLabel || n.backLabel || 'Return to main path';
              btn.onclick = () => updateView(String(n.parentId));
              rightButtons.appendChild(btn);
          }
          
          node.classed('active', d => d.id === activeNodeId)
            .classed('visited-main', d => visitedNodes.has(d.id) && (d.type === 'main' || d.type === 'flip-cards') && d.id !== activeNodeId)
            .classed('visited-sidequest', d => visitedNodes.has(d.id) && d.type === 'sidequest' && d.id !== activeNodeId)
            .classed('unvisited', d => !visitedNodes.has(d.id));
          link.classed('visited-main', d => visitedNodes.has(d.source.id) && visitedNodes.has(d.target.id))
            .classed('visited-sidequest', d => visitedNodes.has(d.source.id) && visitedNodes.has(d.target.id) && (nodeById.get(d.source.id)?.type === 'sidequest' || nodeById.get(d.target.id)?.type === 'sidequest'));
          centerNode(nodeId);
        }

        const resizer = document.getElementById('resizer'); const sidebar = document.getElementById('flow-map-container'); const closeBtn = document.getElementById('close-sidebar-btn'); const openBtn = document.getElementById('open-sidebar-btn');
        let isResizing = false;
        resizer.addEventListener('mousedown', (e) => { isResizing = true; document.body.style.cursor = 'col-resize'; sidebar.style.transition = 'none'; });
        window.addEventListener('mousemove', (e) => { if (!isResizing) return; const newWidth = e.clientX; if (newWidth > 200 && newWidth < document.body.clientWidth - 400) { sidebar.style.width = newWidth + 'px'; updateMainPathPositions(); simulation.alpha(0.1).restart(); } });
        window.addEventListener('mouseup', (e) => { if (isResizing) { isResizing = false; document.body.style.cursor = 'default'; sidebar.style.transition = ''; updateMainPathPositions(); simulation.alpha(0.3).restart(); } });
        closeBtn.addEventListener('click', () => { sidebar.classList.add('collapsed'); openBtn.style.display = 'block'; });
        openBtn.addEventListener('click', () => { sidebar.classList.remove('collapsed'); openBtn.style.display = 'none'; setTimeout(() => { updateMainPathPositions(); simulation.alpha(0.3).restart(); }, 300); });

        updateView(activeNodeId);
    })();
  </script>
</body>
</html>